[
["index.html", "OMM report Section 1 Setup 1.1 Installation 1.2 Generate report", " OMM report Philipp C. Muench 2020-07-17 Section 1 Setup 1.1 Installation rm(list = ls()) source(&quot;utils.R&quot;) library(&quot;vcfR&quot;) library(&quot;rmdformats&quot;) library(&quot;ggplot2&quot;) library(&quot;reshape2&quot;) library(&quot;ggridges&quot;) library(&quot;data.table&quot;) library(&quot;knitr&quot;) library(&quot;kableExtra&quot;) library(&quot;plotly&quot;) library(&quot;DT&quot;) library(&quot;circlize&quot;) library(&quot;ComplexHeatmap&quot;) library(&quot;rtracklayer&quot;) library(&quot;bookdown&quot;) 1.2 Generate report setwd(&quot;~/ActiveProjects/OligoMM-report&quot;) bookdown::serve_book(getwd()) Note: for rtracklayer you might need curl sudo apt-get install libcurl4-openssl-dev You need to install Pandoc. servr::daemon_stop(1) This will starts a browser window pointing to http://127.0.0.1:7853 presenting the report written in R Markdown and will update as soon as there are changes on .Rmd files in the workspace. "],
["claudia-samples.html", "Section 2 Claudia Samples 2.1 Experiment 2.2 Metadata 2.3 OligoMM 2.4 Load in variants 2.5 Filter out of abnormal high mutation 2.6 AF frequency 2.7 number of variants per group 2.8 Heatmap", " Section 2 Claudia Samples 2.1 Experiment 2.2 Metadata designdf &lt;- read.table(&quot;data/sample_mapping.tsv&quot;, header = T, sep = &quot;\\t&quot;) DT::datatable(designdf) 2.3 OligoMM ID phylum species YL44 Verrucomicrobia A. muciniphila I48 Bacteroidetes B. caecimuris YL27 Bacteroidetes M. intestinale YL45 Proteobacteria T. muris YL2 Actinobacteria B. longum KB1 Firmicutes E. faecalis KB18 Firmicutes A. muris YL32 Firmicutes C. clostridioforme YL31 Firmicutes F. plautii YL58 Firmicutes B. coccoides I49 Firmicutes L. reuteri I46 Firmicutes C. innocuum 2.4 Load in variants require(data.table) source(&quot;utils.R&quot;) vcftodataframe &lt;- function(vcf_files, contig_mapping = contig_mapping, gff_df = gff_df) { require(vcfR) res &lt;- list() for (file in vcf_files) { # message(file) vcf_content &lt;- vcfR::read.vcfR(file, verbose = FALSE) vcf_fix &lt;- as.data.frame(vcf_content@fix) vcf_info &lt;- vcfR::INFO2df(vcf_content) # contains DP and AF info if (nrow(vcf_fix) &gt; 0) { # there are variants dat &lt;- as.data.frame(cbind(vcf_fix[, c(1, 2, 4, 5, 6)], vcf_info[, c(1, 2)])) dat$majorAF &lt;- sapply(dat$AF, minorAfToMajorAf) dat$dp &lt;- as.numeric(as.matrix(vcf_info$DP)) dat$genome &lt;- contig_mapping[match(dat$CHROM, contig_mapping$contig), ]$genome dat$genome_hr &lt;- translateGenomeIdToFullName(tolower(dat$genome)) dat$mouse.id &lt;- substr(tools::file_path_sans_ext(basename(file)), 1, 4) # add studz type specific annotations dat$mouse.group &lt;- designdf[match(dat$mouse.id, designdf$mouse.id), ]$desc dat$day &lt;- designdf[match(dat$mouse.id, designdf$mouse.id), ]$day dat$generation &lt;- designdf[match(dat$mouse.id, designdf$mouse.id), ]$generation dat$ecoli &lt;- designdf[match(dat$mouse.id, designdf$mouse.id), ]$ecoli dat$sample &lt;- tools::file_path_sans_ext(basename(file)) # annotate overlay of gene dt_gff &lt;- data.table(start = gff_df$start, end = gff_df$end, chr = as.character(as.matrix(gff_df$chr)), feature = gff_df$product) colnames(dat)[1:2] &lt;- c(&quot;chr&quot;, &quot;start&quot;) dat$start &lt;- as.integer(as.matrix(dat$start)) dat$chr &lt;- as.character(as.matrix(dat$chr)) dat$end &lt;- dat$start dat2 &lt;- as.data.table(dat) setkey(dt_gff, chr, start, end) annotated &lt;- foverlaps(dat2, dt_gff, type = &quot;within&quot;, mult = &quot;first&quot;) res[[tools::file_path_sans_ext(basename(file))]] &lt;- annotated # add vcf df to list } else { message(&quot;Skipping&quot;) } } df &lt;- as.data.frame(do.call(rbind, res)) # merge list to df return(df) } Merge vcf and annotate with metadata # load in reference information gff_files &lt;- Sys.glob(&quot;data/references/joined_reference_curated_ecoli/*.gff&quot;) gff_df &lt;- NULL for (gff_file in gff_files) { message(gff_file) gff &lt;- rtracklayer::readGFF(gff_file) # subset since different columns are present on gff files relevant &lt;- data.frame(start = gff$start, end = gff$end, type = as.character(as.matrix(gff$type)), gene = as.character(as.matrix(gff$gene)), product = as.character(as.matrix(gff$product)), chr = as.character(as.matrix(gff$seqid))) relevant$genome &lt;- substr(basename(gff_file), 1, nchar(basename(gff_file)) - 4) gff_df &lt;- rbind(gff_df, relevant) } ## data/references/joined_reference_curated_ecoli/joined_reference_curated_ecoli.gff # load in contig information contig_mapping &lt;- read.csv2(&quot;data/contig_mapping_new_ref.csv&quot;, sep = &quot;;&quot;, header = T, stringsAsFactors = F) # load in vcf files vcf_files &lt;- Sys.glob(&quot;out_claudia/all_vcf/*.vcf&quot;) vcf_samples &lt;- suppressWarnings(vcftodataframe(vcf_files, contig_mapping, gff_df = gff_df)) vcf_samples$feature &lt;- as.character(as.matrix(vcf_samples$feature)) vcf_samples[which(is.na(vcf_samples$feature)), ]$feature &lt;- &quot;outside ORFs&quot; vcf_samples$start &lt;- NULL vcf_samples$end &lt;- NULL vcf_samples$i.end &lt;- NULL colnames(vcf_samples)[3] &lt;- &quot;POS&quot; vcf_samples$ref_size &lt;- nchar(as.character(as.matrix(vcf_samples$REF))) vcf_samples$alt_size &lt;- nchar(as.character(as.matrix(vcf_samples$ALT))) vcf_samples$alteration &lt;- paste(as.character(vcf_samples$REF), &quot;-&gt;&quot;, as.character(vcf_samples$ALT)) vcf_samples$alteration_type &lt;- &quot;SNP&quot; vcf_samples[which(vcf_samples$ref_size &lt; vcf_samples$alt_size), ]$alteration_type &lt;- &quot;insertion&quot; vcf_samples[which(vcf_samples$ref_size &gt; vcf_samples$alt_size), ]$alteration_type &lt;- &quot;deletion&quot; saveRDS(vcf_samples, file = &quot;data/rds/omm_claudia_new.rds&quot;) 2.5 Filter out of abnormal high mutation We filter out samples that have a mutation rate of the global mean. dat &lt;- readRDS(&quot;data/rds/omm_claudia_new.rds&quot;) dat &lt;- dat[which(dat$alteration_type == &quot;SNP&quot;), ] dat$dummy &lt;- 1 # summarize by alteration type dat.agg &lt;- aggregate(dummy ~ alteration + sample, dat, sum) dat.agg &lt;- dat.agg[order(-dat.agg$dummy), ] median_threshold &lt;- mean(dat.agg$dummy) p &lt;- ggplot(dat.agg, aes(x = reorder(sample, dummy), y = dummy, group = alteration)) + ylab(&quot;number of SNPs (log10)&quot;) + xlab(&quot;samples&quot;) p &lt;- p + geom_bar(stat = &quot;identity&quot;) + coord_flip() + facet_wrap(~alteration) + scale_y_log10() p &lt;- p + theme_bw() + geom_hline(yintercept = median_threshold, colour = &quot;grey50&quot;) print(p) Figure 2.1: Mutation profile before removal. Vertical line is the global mean number of mutation rates # remove all C&gt;A and G&gt;T on selected samples affected_samples &lt;- dat.agg[which(dat.agg$dummy &gt; median_threshold), ]$sample dat &lt;- readRDS(&quot;data/rds/omm_claudia_new.rds&quot;) dat_outlier &lt;- which(dat$alteration_type == &quot;SNP&quot; &amp; dat$sample %in% affected_samples &amp; (dat$alteration == &quot;C -&gt; A&quot; | dat$alteration == &quot;G -&gt; T&quot;)) dat_corrected &lt;- dat[-dat_outlier, ] saveRDS(dat_corrected, file = &quot;data/rds/omm_claudia_new.rds&quot;) nrow(dat_corrected) # number of variants in total ## [1] 22707 # plot again dat_corrected2 &lt;- dat_corrected[which(dat_corrected$alteration_type == &quot;SNP&quot;), ] dat_corrected2$dummy &lt;- 1 # summarize by alteration type dat_corrected2.agg &lt;- aggregate(dummy ~ alteration + sample, dat_corrected2, sum) p &lt;- ggplot(dat_corrected2.agg, aes(x = reorder(sample, dummy), y = dummy, group = alteration)) + ylab(&quot;number of SNPs (log10)&quot;) + xlab(&quot;samples&quot;) p &lt;- p + geom_bar(stat = &quot;identity&quot;) + coord_flip() + facet_wrap(~alteration) + scale_y_log10() p &lt;- p + theme_bw() + geom_hline(yintercept = median_threshold, colour = &quot;grey50&quot;) print(p) Figure 2.2: Mutation profile after removal. Vertical line is the global mean number of mutation rates befor filtering 2.6 AF frequency dat &lt;- readRDS(&quot;data/rds/omm_claudia_new.rds&quot;) library(scales) p &lt;- ggplot(dat, aes(AF, fill = mouse.group)) + geom_histogram() p &lt;- p + facet_wrap(~genome + genome_hr, scales = &quot;free&quot;, ncol = 3) p &lt;- p + xlab(&quot;AF&quot;) + ylab(&quot;occurence&quot;) + theme_minimal() plotly::ggplotly(p) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Figure 2.3: AF of resequenced strains dat &lt;- readRDS(&quot;data/rds/omm_claudia_new.rds&quot;) p &lt;- ggplot(dat, aes(majorAF, fill = mouse.group)) + geom_histogram() p &lt;- p + theme_minimal() p &lt;- p + facet_wrap(~genome + genome_hr, scales = &quot;free&quot;, ncol = 3) p &lt;- p + xlab(&quot;AF&quot;) + ylab(&quot;occurence&quot;) plotly::ggplotly(p) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Figure 2.4: major AF of resequenced strains 2.7 number of variants per group dat &lt;- readRDS(&quot;data/rds/omm_claudia_new.rds&quot;) dat$variants &lt;- 1 dat.agg &lt;- aggregate(variants ~ mouse.id + alteration_type + genome_hr, dat, sum) DT::datatable(dat.agg) 2.7.1 number of variants per treatment group 2.7.2 deletion dat &lt;- readRDS(&quot;data/rds/omm_claudia_new.rds&quot;) dat$variants &lt;- 1 dat.agg &lt;- aggregate(variants ~ mouse.id + mouse.group + alteration_type + genome_hr, dat, sum) p &lt;- ggplot(dat.agg, aes(x = reorder(mouse.id, -variants), y = variants, color = alteration_type, group = alteration_type, shape = factor(alteration_type))) p &lt;- p + geom_jitter(size = 0.4) + facet_grid(genome_hr ~ mouse.group, space = &quot;free&quot;, scales = &quot;free_x&quot;) p &lt;- p + geom_line() + scale_y_log10() p &lt;- p + theme_minimal() + ylab(&quot;number variants&quot;) p &lt;- p + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) p ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? ## geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic? Figure 2.5: total number of variants of all 12 OMM genomes by mouse and grouyp stratified by variant type. Seems there is still a outlier (20 cecal content caecimuris, where some samples have more than 1000 varaints) 2.8 Heatmap library(circlize) library(ComplexHeatmap) dat &lt;- readRDS(&quot;data/rds/omm_claudia_new.rds&quot;) dat$variant.id &lt;- paste0(dat$POS, &quot;-&quot;, dat$REF, &quot;-&quot;, dat$ALT) data.wide &lt;- dcast(dat, variant.id ~ sample, value.var = &quot;AF&quot;) ## Warning in dcast(dat, variant.id ~ sample, value.var = &quot;AF&quot;): The dcast generic in data.table has been ## passed a data.frame and will attempt to redirect to the reshape2::dcast; please note that reshape2 is ## deprecated, and this redirection is now deprecated as well. Please do this redirection yourself like ## reshape2::dcast(dat). In the next version, this warning will become an error. data.wide[is.na(data.wide)] &lt;- 0 rownames(data.wide) &lt;- data.wide$variant.id data.wide$variant.id &lt;- NULL heat &lt;- data.matrix(data.wide) # limit to variants that are present in at least 10% of samples heat_num &lt;- rowSums(heat != 0) heat2 &lt;- heat[which(heat_num &gt; ncol(heat)/10),] dat$dummy &lt;- 1 annot.data &lt;- aggregate(dummy ~ sample + mouse.group + day, dat, sum) heat3.day &lt;- annot.data[match(colnames(heat2), annot.data$sample),]$day heat3.mouse.group &lt;- annot.data[match(colnames(heat2), annot.data$sample),]$mouse.group #data.wide.sub &lt;- dat[match(colnames(heat3), dat$sample.id),] col_fun = colorRamp2(c(0, 0.5, 1), c(&quot;white&quot;, &quot;yellow&quot;, &quot;red&quot;)) Heatmap(heat2 , name = &quot;AF&quot;, border = TRUE, col = col_fun, right_annotation = rowAnnotation(prev = anno_lines(rowSums(heat2))), cluster_columns = T, row_gap = unit(0, &quot;mm&quot;), column_gap = unit(0, &quot;mm&quot;), column_names_gp = gpar(fontsize =5), row_names_gp = gpar(fontsize = 3), show_row_dend = F, show_row_names = F, show_column_dend = T, top_annotation = HeatmapAnnotation(day=anno_simple(heat3.day), mouse_group = anno_simple(heat3.mouse.group)) ) "],
["ab-effects-resequenced.html", "Section 3 AB-effects (resequenced) 3.1 Metadata 3.2 Process Lofeq vcf files 3.3 Plot AF frequency 3.4 KB1 3.5 I46 3.6 YL58 3.7 mutation bias? 3.8 heatmap 3.9 Filter: present in all", " Section 3 AB-effects (resequenced) 3.1 Metadata Sample Genome Group Species Treatment DR4 KB1 1687 Enterococcus_faecalis Ciprofloxacin DR1 KB1 1681 Enterococcus_faecalis Water DR8 KB1 1691 Enterococcus_faecalis Tetracyclin DR11 KB1 1696 Enterococcus_faecalis Vancomycin DR3 I46 1681 Clostridium_innocuum Water DR6 I46 1687 Clostridium_innocuum Ciprofloxacin DR10 I46 1691 Clostridium_innocuum Tetracyclin DR12 I46 1696 Clostridium_innocuum Vancomycin DR7 YL58 1687 Blautia_coccoides Ciprofloxacin DR13 YL58 1696 Blautia_coccoides Vancomycin 3.2 Process Lofeq vcf files source(&quot;utils.R&quot;) orf_shapes = c(coding = 15, `non-coding` = 3) vcfToDataframe &lt;- function(vcf.files, contig_mapping = contig_mapping, gff.df = gff.df) { require(vcfR) res &lt;- list() for (file in vcf.files) { # message(file) library(data.table) vcf.content &lt;- vcfR::read.vcfR(file, verbose = FALSE) vcf.fix &lt;- as.data.frame(vcf.content@fix) # contains chr, position and substitution informations vcf.info &lt;- vcfR::INFO2df(vcf.content) # get INFO field, contains DP, AF informations # no annotation since they are not yet processed with snpEff vcf.ann &lt;- data.frame(do.call(&#39;rbind&#39;, # strsplit(as.character(vcf.info$ANN),&#39;|&#39;,fixed = TRUE))) # split ANN field, contains information if files # are processed by snpEff there are variants if (nrow(vcf.fix) &gt; 0) { dat &lt;- as.data.frame(cbind(vcf.fix[, c(1, 2, 4, 5, 6)], vcf.info[, c(1, 2)])) dat$majorAF &lt;- sapply(dat$AF, minorAfToMajorAf) # transforms e.g. AF of 0.1 to 0.9, 0.9 stays 0.9 and 0.5 stays 0.5 dat$genome &lt;- contig_mapping[match(dat$CHROM, contig_mapping$contig), ]$genome # map chr information to genome name e.g. NHMU01000001.1 -&gt; i48 dat$genome_hr &lt;- translateGenomeIdToFullName(tolower(dat$genome)) dat$mouse.id &lt;- translateSampletoMouse(tools::file_path_sans_ext(basename(file))) dat$mouse.group &lt;- translateMouseIdToTreatmentGroup(translateSampletoMouse(tools::file_path_sans_ext(basename(file)))) dat$dp &lt;- as.numeric(as.matrix(vcf.info$DP)) dt.gff &lt;- data.table(start = gff.df$start, end = gff.df$end, chr = as.character(as.matrix(gff.df$chr)), feature = gff.df$product) colnames(dat)[1:2] &lt;- c(&quot;chr&quot;, &quot;start&quot;) dat$start &lt;- as.integer(as.matrix(dat$start)) dat$chr &lt;- as.character(as.matrix(dat$chr)) dat$end &lt;- dat$start dat2 &lt;- as.data.table(dat) setkey(dt.gff, chr, start, end) annotated &lt;- foverlaps(dat2, dt.gff, type = &quot;within&quot;, mult = &quot;first&quot;) res[[tools::file_path_sans_ext(basename(file))]] &lt;- annotated # add vcf df to list } else { message(&quot;Skipping&quot;) } } df &lt;- as.data.frame(do.call(rbind, res)) # merge list to df return(df) } gff.files &lt;- Sys.glob(&quot;data/references/gff/*.gff&quot;) gff.df &lt;- NULL for (gff.file in gff.files) { message(gff.file) gff &lt;- rtracklayer::readGFF(gff.file) # subset since different columns are present on gff files relevant &lt;- data.frame(start = gff$start, end = gff$end, type = as.character(as.matrix(gff$type)), gene = as.character(as.matrix(gff$gene)), product = as.character(as.matrix(gff$product)), chr = as.character(as.matrix(gff$seqid))) relevant$genome &lt;- substr(basename(gff.file), 1, nchar(basename(gff.file)) - 4) gff.df &lt;- rbind(gff.df, relevant) } ## data/references/gff/I46.gff ## data/references/gff/KB1.gff ## data/references/gff/YL58.gff contig_mapping &lt;- read.csv2(&quot;data/contig_mapping_new_ref.csv&quot;, sep = &quot;;&quot;, header = T, stringsAsFactors = F) # this file contains contig names of the 12 OligoMM genomes vcf.files &lt;- Sys.glob(&quot;out_reseq/all_vcf/*.vcf&quot;) vcf.samples &lt;- suppressWarnings(vcfToDataframe(vcf.files, contig_mapping, gff.df = gff.df)) vcf.samples$feature &lt;- as.character(as.matrix(vcf.samples$feature)) vcf.samples[which(is.na(vcf.samples$feature)), ]$feature &lt;- &quot;outside ORFs&quot; vcf.samples[which(vcf.samples$feature == &quot;hypothetical protein&quot;), ]$feature &lt;- &quot;hypothetical proteins&quot; vcf.samples$start &lt;- NULL vcf.samples$end &lt;- NULL vcf.samples$i.end &lt;- NULL colnames(vcf.samples)[3] &lt;- &quot;POS&quot; vcf.samples$ref_size &lt;- nchar(as.character(as.matrix(vcf.samples$REF))) vcf.samples$alt_size &lt;- nchar(as.character(as.matrix(vcf.samples$ALT))) vcf.samples$alteration &lt;- paste(as.character(vcf.samples$REF), &quot;-&gt;&quot;, as.character(vcf.samples$ALT)) vcf.samples$alteration_type &lt;- &quot;SNP&quot; vcf.samples[which(vcf.samples$ref_size &lt; vcf.samples$alt_size), ]$alteration_type &lt;- &quot;insertion&quot; vcf.samples[which(vcf.samples$ref_size &gt; vcf.samples$alt_size), ]$alteration_type &lt;- &quot;deletion&quot; saveRDS(vcf.samples, file = &quot;data/rds/reseq.rds&quot;) Save as table dat &lt;- readRDS(&quot;data/rds/reseq.rds&quot;) write.table(vcf_samples, file = &quot;results/tables/omm_antibiotic_resequencing_variants_long.csv&quot;, sep = &quot;;&quot;, col.names = T, row.names = F, quote = F) 3.3 Plot AF frequency dat &lt;- readRDS(&quot;data/rds/reseq.rds&quot;) p1 &lt;- ggplot(dat, aes(AF, fill = genome)) + geom_histogram() p1 &lt;- p1 + facet_grid(mouse.id + mouse.group ~ genome + genome_hr) p1 &lt;- p1 + theme_minimal() + xlab(&quot;AF&quot;) + ylab(&quot;occurence&quot;) plotly::ggplotly(p1) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Figure 3.1: AF of resequenced strains p &lt;- ggplot(dat, aes(majorAF, fill = genome)) + geom_histogram() p &lt;- p + facet_grid(mouse.id + mouse.group ~ genome + genome_hr) p &lt;- p + theme_minimal() + xlab(&quot;AF&quot;) + ylab(&quot;occurence&quot;) plotly::ggplotly(p) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Figure 3.2: major AF of resequenced strains pairedAFplot &lt;- function(dat = dat, case = &quot;Water&quot;, control = &quot;Ciprofloxacin&quot;) { require(reshape2) require(ggplot2) dat.pair &lt;- dat[which(dat$mouse.group == case | dat$mouse.group == control), ] # dat.pair &lt;- dat.pair[which(dat.pair$genome == genome),] # dat.pair &lt;- dat.pair[which(!is.na(dat.pair$feature)),] data.wide &lt;- dcast(dat.pair, genome + POS + REF + ALT + feature ~ mouse.group, value.var = &quot;AF&quot;) data.wide$vartype &lt;- ifelse(as.character(data.wide$feature) != &quot;outside ORFs&quot;, &quot;coding&quot;, &quot;non-coding&quot;) data.wide &lt;- data.wide[which(data.wide$vartype != 0), ] colnames(data.wide)[6] &lt;- &quot;sample_1&quot; colnames(data.wide)[7] &lt;- &quot;sample_2&quot; data.wide[is.na(data.wide)] &lt;- 0 p &lt;- ggplot(data.wide, aes(x = sample_2, y = sample_1, label = feature, color = genome, shape = vartype)) p &lt;- p + geom_point(fill = NA) + theme_classic() # + scale_color_manual(values = omm_colors) p &lt;- p + theme(aspect.ratio = 1) p &lt;- p + geom_hline(yintercept = 0.5, linetype = 2, color = &quot;grey50&quot;) p &lt;- p + geom_vline(xintercept = 0.5, linetype = 2, color = &quot;grey50&quot;) p &lt;- p + scale_shape_manual(values = orf_shapes) p &lt;- p + theme(aspect.ratio = 1) p &lt;- p + theme(strip.background = element_blank()) p &lt;- p + geom_abline(intercept = 0, slope = 1) p &lt;- p + xlab(case) + ylab(control) p &lt;- p + theme(panel.border = element_rect(colour = &quot;black&quot;, fill = NA, size = 1)) return(p) } suppressWarnings(ggplotly(pairedAFplot(dat, case = &quot;Water&quot;, control = &quot;Ciprofloxacin&quot;))) Figure 3.3: Scatter plot of AF of two samples. Only variants with functional annotation are shown suppressWarnings(ggplotly(pairedAFplot(dat, case = &quot;Water&quot;, control = &quot;Tetracyclin&quot;))) Figure 3.4: Scatter plot of AF of two samples. Only variants with functional annotation are shown suppressWarnings(ggplotly(pairedAFplot(dat, case = &quot;Water&quot;, control = &quot;Vancomycin&quot;))) Figure 3.5: Scatter plot of AF of two samples. Only variants with functional annotation are shown dat &lt;- readRDS(&quot;data/rds/reseq.rds&quot;) dat$ref_size &lt;- nchar(as.character(as.matrix(dat$REF))) dat$alt_size &lt;- nchar(as.character(as.matrix(dat$ALT))) dat$alteration &lt;- paste(as.character(dat$REF), &quot;-&gt;&quot;, as.character(dat$ALT)) # no grid version for html geneCentricPlot2 &lt;- function(dat = dat, genome = &quot;KB1&quot;, type = &quot;SNP&quot;) { require(reshape2) require(ggplot2) dat.subset &lt;- dat[which(dat$genome == genome), ] if (type == &quot;SNP&quot;) { dat.subset &lt;- dat.subset[which(dat.subset$ref_size == 1 &amp; dat.subset$alt_size == 1), ] } else if (type == &quot;insertion&quot;) { dat.subset &lt;- dat.subset[which(dat.subset$ref_size == 1 &amp; dat.subset$alt_size &gt; 1), ] } else { # deletion dat.subset &lt;- dat.subset[which(dat.subset$ref_size &gt; 1 &amp; dat.subset$alt_size == 1), ] } dat.subset$ID &lt;- paste0(dat.subset$POS, &quot;|&quot;, dat.subset$REF, &quot;-&gt;&quot;, dat.subset$ALT) p &lt;- ggplot(dat.subset, aes(x = feature, y = AF, color = mouse.group, label = alteration)) p &lt;- p + geom_point(size = 2, fill = NA) p &lt;- p + coord_flip() + theme_classic() p &lt;- p + ylim(c(0, 1)) p &lt;- p + theme(strip.background = element_blank()) + theme(strip.text.y = element_text(angle = 0), strip.placement = &quot;outside&quot;) p &lt;- p + xlab(&quot;&quot;) + ylab(&quot;allele frequency&quot;) return(p) } 3.4 KB1 3.4.1 SNP suppressWarnings(ggplotly(geneCentricPlot2(dat, genome = &quot;KB1&quot;, type = &quot;SNP&quot;))) Figure 3.6: AF by function of one genome 3.4.2 insertion suppressWarnings(ggplotly(geneCentricPlot2(dat, genome = &quot;KB1&quot;, type = &quot;insertion&quot;))) Figure 3.7: AF by function of one genome 3.4.3 deletion suppressWarnings(ggplotly(geneCentricPlot2(dat, genome = &quot;KB1&quot;, type = &quot;deletion&quot;))) Figure 3.8: AF by function of one genome 3.5 I46 3.5.1 SNP suppressWarnings(ggplotly(geneCentricPlot2(dat, genome = &quot;I46&quot;, type = &quot;SNP&quot;))) Figure 3.9: AF by function of one genome 3.5.2 insertion suppressWarnings(ggplotly(geneCentricPlot2(dat, genome = &quot;I46&quot;, type = &quot;insertion&quot;))) Figure 3.10: AF by function of one genome 3.5.3 deletion suppressWarnings(ggplotly(geneCentricPlot2(dat, genome = &quot;I46&quot;, type = &quot;deletion&quot;))) Figure 3.11: AF by function of one genome 3.6 YL58 3.6.1 SNP suppressWarnings(ggplotly(geneCentricPlot2(dat, genome = &quot;YL58&quot;, type = &quot;SNP&quot;))) Figure 3.12: AF by function of one genome 3.6.2 insertion suppressWarnings(ggplotly(geneCentricPlot2(dat, genome = &quot;YL58&quot;, type = &quot;insertion&quot;))) Figure 3.13: AF by function of one genome 3.6.3 deletion suppressWarnings(ggplotly(geneCentricPlot2(dat, genome = &quot;YL58&quot;, type = &quot;deletion&quot;))) Figure 3.14: AF by function of one genome 3.7 mutation bias? 3.7.1 SNP dat &lt;- readRDS(&quot;data/rds/reseq.rds&quot;) dat$ref_size &lt;- nchar(as.character(as.matrix(dat$REF))) dat$alt_size &lt;- nchar(as.character(as.matrix(dat$ALT))) dat &lt;- dat[which(dat$ref_size == 1 &amp; dat$alt_size == 1), ] dat$alteration &lt;- paste(as.character(dat$REF), &quot;-&gt;&quot;, as.character(dat$ALT)) dat$dummy &lt;- 1 dat.agg &lt;- aggregate(dummy ~ genome + mouse.group + alteration, dat, sum) p &lt;- ggplot(dat.agg, aes(x = mouse.group, y = dummy, label = alteration, color = genome)) p &lt;- p + geom_text() + facet_grid(~genome) + ylab(&quot;occurrence&quot;) p &lt;- p + stat_summary(fun.y = mean, geom = &quot;line&quot;, aes(group = alteration), alpha = 0.1) p &lt;- p + theme_classic() # + scale_color_manual(values = omm_colors) ggplotly(p) 3.7.2 insertions dat &lt;- readRDS(&quot;data/rds/reseq.rds&quot;) dat$ref_size &lt;- nchar(as.character(as.matrix(dat$REF))) dat$alt_size &lt;- nchar(as.character(as.matrix(dat$ALT))) dat &lt;- dat[which(dat$alt_size &gt; dat$ref_size), ] dat$alteration &lt;- paste(as.character(dat$REF), &quot;-&gt;&quot;, as.character(dat$ALT)) dat$dummy &lt;- 1 dat.agg &lt;- aggregate(dummy ~ genome + mouse.group + alteration, dat, sum) p &lt;- ggplot(dat.agg, aes(x = mouse.group, y = dummy, label = alteration, color = genome)) p &lt;- p + geom_text() + facet_grid(~genome) + ylab(&quot;occurrence&quot;) p &lt;- p + stat_summary(fun.y = mean, geom = &quot;line&quot;, aes(group = alteration), alpha = 0.1) p &lt;- p + theme_classic() # + scale_color_manual(values = omm_colors) ggplotly(p) 3.7.3 deletions dat &lt;- readRDS(&quot;data/rds/reseq.rds&quot;) dat$ref_size &lt;- nchar(as.character(as.matrix(dat$REF))) dat$alt_size &lt;- nchar(as.character(as.matrix(dat$ALT))) dat &lt;- dat[which(dat$alt_size &lt; dat$ref_size), ] dat$alteration &lt;- paste(as.character(dat$REF), &quot;-&gt;&quot;, as.character(dat$ALT)) dat$dummy &lt;- 1 dat.agg &lt;- aggregate(dummy ~ genome + mouse.group + alteration, dat, sum) p &lt;- ggplot(dat.agg, aes(x = mouse.group, y = dummy, label = alteration, color = genome)) p &lt;- p + geom_text() + facet_grid(~genome) + ylab(&quot;occurrence&quot;) p &lt;- p + stat_summary(fun.y = mean, geom = &quot;line&quot;, aes(group = alteration), alpha = 0.1) p &lt;- p + theme_classic() # + scale_color_manual(values = omm_colors) ggplotly(p) 3.8 heatmap 3.8.1 KB1 dat &lt;- readRDS(&quot;data/rds/reseq.rds&quot;) # dat &lt;- dat[which(dat$mouse.group == &#39;Water&#39; | dat$mouse.group == &#39;Tetracyclin&#39; ),] data.wide &lt;- dcast(dat, genome + POS + REF + ALT + feature ~ mouse.group, value.var = &quot;AF&quot;) ## Warning in dcast(dat, genome + POS + REF + ALT + feature ~ mouse.group, : The dcast generic in data.table ## has been passed a data.frame and will attempt to redirect to the reshape2::dcast; please note that ## reshape2 is deprecated, and this redirection is now deprecated as well. Please do this redirection ## yourself like reshape2::dcast(dat). In the next version, this warning will become an error. data.wide &lt;- data.wide[which(data.wide$genome == &quot;KB1&quot;), ] rownames(data.wide) &lt;- paste0(data.wide$POS, &quot;-&quot;, data.wide$REF, &quot;-&quot;, data.wide$ALT) heat &lt;- data.matrix(data.wide[, 6:9]) library(circlize) library(ComplexHeatmap) heat[is.na(heat)] &lt;- 0 col_fun = colorRamp2(c(0, 0.5, 1), c(&quot;white&quot;, &quot;yellow&quot;, &quot;red&quot;)) Heatmap(heat, name = &quot;AF&quot;, col = col_fun, column_names_gp = gpar(fontsize = 9), row_names_gp = gpar(fontsize = 3), show_row_dend = F, show_row_names = F, show_column_dend = F) 3.8.2 I46 dat &lt;- readRDS(&quot;data/rds/reseq.rds&quot;) # dat &lt;- dat[which(dat$mouse.group == &#39;Water&#39; | dat$mouse.group == &#39;Tetracyclin&#39; ),] data.wide &lt;- dcast(dat, genome + POS + REF + ALT + feature ~ mouse.group, value.var = &quot;AF&quot;) ## Warning in dcast(dat, genome + POS + REF + ALT + feature ~ mouse.group, : The dcast generic in data.table ## has been passed a data.frame and will attempt to redirect to the reshape2::dcast; please note that ## reshape2 is deprecated, and this redirection is now deprecated as well. Please do this redirection ## yourself like reshape2::dcast(dat). In the next version, this warning will become an error. data.wide &lt;- data.wide[which(data.wide$genome == &quot;I46&quot;), ] rownames(data.wide) &lt;- paste0(data.wide$POS, &quot;-&quot;, data.wide$REF, &quot;-&quot;, data.wide$ALT) heat &lt;- data.matrix(data.wide[, 6:9]) library(circlize) library(ComplexHeatmap) heat[is.na(heat)] &lt;- 0 col_fun = colorRamp2(c(0, 0.5, 1), c(&quot;white&quot;, &quot;yellow&quot;, &quot;red&quot;)) Heatmap(heat, name = &quot;AF&quot;, col = col_fun, column_names_gp = gpar(fontsize = 9), row_names_gp = gpar(fontsize = 9), show_row_names = F, show_row_dend = F, show_column_dend = F) 3.8.3 YL58 dat &lt;- readRDS(&quot;data/rds/reseq.rds&quot;) # dat &lt;- dat[which(dat$mouse.group == &#39;Water&#39; | dat$mouse.group == &#39;Tetracyclin&#39; ),] data.wide &lt;- dcast(dat, genome + POS + REF + ALT + feature ~ mouse.group, value.var = &quot;AF&quot;) ## Warning in dcast(dat, genome + POS + REF + ALT + feature ~ mouse.group, : The dcast generic in data.table ## has been passed a data.frame and will attempt to redirect to the reshape2::dcast; please note that ## reshape2 is deprecated, and this redirection is now deprecated as well. Please do this redirection ## yourself like reshape2::dcast(dat). In the next version, this warning will become an error. data.wide &lt;- data.wide[which(data.wide$genome == &quot;YL58&quot;), ] rownames(data.wide) &lt;- paste0(data.wide$POS, &quot;-&quot;, data.wide$REF, &quot;-&quot;, data.wide$ALT) heat &lt;- data.matrix(data.wide[, 6:9]) library(circlize) library(ComplexHeatmap) heat[is.na(heat)] &lt;- 0 col_fun = colorRamp2(c(0, 0.5, 1), c(&quot;white&quot;, &quot;yellow&quot;, &quot;red&quot;)) Heatmap(heat, name = &quot;AF&quot;, col = col_fun, column_names_gp = gpar(fontsize = 9), row_names_gp = gpar(fontsize = 9), show_row_dend = F, show_row_names = F, show_column_dend = F) 3.9 Filter: present in all 3.9.1 KB1 (Enterococcusfaecalis) dat &lt;- readRDS(&quot;data/rds/reseq.rds&quot;) # dat &lt;- dat[which(dat$mouse.group == &#39;Water&#39; | dat$mouse.group == &#39;Tetracyclin&#39; ),] data.wide &lt;- dcast(dat, genome + POS + REF + ALT + feature ~ mouse.group, value.var = &quot;AF&quot;) ## Warning in dcast(dat, genome + POS + REF + ALT + feature ~ mouse.group, : The dcast generic in data.table ## has been passed a data.frame and will attempt to redirect to the reshape2::dcast; please note that ## reshape2 is deprecated, and this redirection is now deprecated as well. Please do this redirection ## yourself like reshape2::dcast(dat). In the next version, this warning will become an error. data.wide &lt;- data.wide[which(data.wide$genome == &quot;KB1&quot;), ] rownames(data.wide) &lt;- paste0(data.wide$POS, &quot; (&quot;, data.wide$REF, &quot; -&gt; &quot;, data.wide$ALT, &quot;) &quot;, data.wide$feature) heat &lt;- data.matrix(data.wide[, 6:9]) heat &lt;- heat[which(rowSums(!is.na(heat)) &gt; 2), ] # filter uncommon library(circlize) library(ComplexHeatmap) heat[is.na(heat)] &lt;- 0 col_fun = colorRamp2(c(0, 0.5, 1), c(&quot;white&quot;, &quot;yellow&quot;, &quot;red&quot;)) Heatmap(heat, name = &quot;AF&quot;, col = col_fun, column_names_gp = gpar(fontsize = 9), row_names_gp = gpar(fontsize = 9), show_row_dend = F, row_names_max_width = unit(10, &quot;cm&quot;), show_row_names = T, show_column_dend = F) 3.9.2 YL58 (Blautia_coccoides) dat &lt;- readRDS(&quot;data/rds/reseq.rds&quot;) # dat &lt;- dat[which(dat$mouse.group == &#39;Water&#39; | dat$mouse.group == &#39;Tetracyclin&#39; ),] data.wide &lt;- dcast(dat, genome + POS + REF + ALT + feature ~ mouse.group, value.var = &quot;AF&quot;) ## Warning in dcast(dat, genome + POS + REF + ALT + feature ~ mouse.group, : The dcast generic in data.table ## has been passed a data.frame and will attempt to redirect to the reshape2::dcast; please note that ## reshape2 is deprecated, and this redirection is now deprecated as well. Please do this redirection ## yourself like reshape2::dcast(dat). In the next version, this warning will become an error. data.wide &lt;- data.wide[which(data.wide$genome == &quot;YL58&quot;), ] rownames(data.wide) &lt;- paste0(data.wide$POS, &quot; (&quot;, data.wide$REF, &quot; -&gt; &quot;, data.wide$ALT, &quot;) &quot;, data.wide$feature) heat &lt;- data.matrix(data.wide[, 6:9]) heat &lt;- heat[which(rowSums(!is.na(heat)) &gt; 2), ] # filter uncommon library(circlize) library(ComplexHeatmap) heat[is.na(heat)] &lt;- 0 col_fun = colorRamp2(c(0, 0.5, 1), c(&quot;white&quot;, &quot;yellow&quot;, &quot;red&quot;)) Heatmap(heat, name = &quot;AF&quot;, col = col_fun, row_names_max_width = unit(10, &quot;cm&quot;), column_names_gp = gpar(fontsize = 9), row_names_gp = gpar(fontsize = 9), show_row_dend = F, show_row_names = T, show_column_dend = F) 3.9.3 I46 (Clostridium innocuum) dat &lt;- readRDS(&quot;data/rds/reseq.rds&quot;) # dat &lt;- dat[which(dat$mouse.group == &#39;Water&#39; | dat$mouse.group == &#39;Tetracyclin&#39; ),] data.wide &lt;- dcast(dat, genome + POS + REF + ALT + feature ~ mouse.group, value.var = &quot;AF&quot;) ## Warning in dcast(dat, genome + POS + REF + ALT + feature ~ mouse.group, : The dcast generic in data.table ## has been passed a data.frame and will attempt to redirect to the reshape2::dcast; please note that ## reshape2 is deprecated, and this redirection is now deprecated as well. Please do this redirection ## yourself like reshape2::dcast(dat). In the next version, this warning will become an error. data.wide &lt;- data.wide[which(data.wide$genome == &quot;I46&quot;), ] rownames(data.wide) &lt;- paste0(data.wide$POS, &quot; (&quot;, data.wide$REF, &quot; -&gt; &quot;, data.wide$ALT, &quot;) &quot;, data.wide$feature) heat &lt;- data.matrix(data.wide[, 6:9]) heat &lt;- heat[which(rowSums(!is.na(heat)) &gt; 2), ] # filter uncommon library(circlize) library(ComplexHeatmap) heat[is.na(heat)] &lt;- 0 col_fun = colorRamp2(c(0, 0.5, 1), c(&quot;white&quot;, &quot;yellow&quot;, &quot;red&quot;)) Heatmap(heat, name = &quot;AF&quot;, col = col_fun, row_names_max_width = unit(10, &quot;cm&quot;), column_names_gp = gpar(fontsize = 9), row_names_gp = gpar(fontsize = 9), show_row_dend = F, show_row_names = T, show_column_dend = F) 3.9.4 Filter: not in water but in AB 3.9.5 KB1 (Enterococcusfaecalis) dat &lt;- readRDS(&quot;data/rds/reseq.rds&quot;) #dat &lt;- dat[which(dat$mouse.group == &quot;Water&quot; | dat$mouse.group == &quot;Tetracyclin&quot; ),] data.wide &lt;- dcast(dat, genome + POS + REF + ALT + feature ~ mouse.group, value.var = &quot;AF&quot;) ## Warning in dcast(dat, genome + POS + REF + ALT + feature ~ mouse.group, : The dcast generic in data.table ## has been passed a data.frame and will attempt to redirect to the reshape2::dcast; please note that ## reshape2 is deprecated, and this redirection is now deprecated as well. Please do this redirection ## yourself like reshape2::dcast(dat). In the next version, this warning will become an error. data.wide &lt;- data.wide[which(data.wide$genome == &quot;KB1&quot;),] rownames(data.wide) &lt;- paste0(data.wide$POS, &quot; (&quot;,data.wide$REF, &quot; -&gt; &quot;,data.wide$ALT, &quot;) &quot;, data.wide$feature) heat &lt;- data.wide[,6:9] heat[is.na(heat)] &lt;- 0 heat &lt;- heat[which(heat$Water &lt; 0.5 &amp; (heat$Ciprofloxacin &gt; 0.5 | heat$Tetracyclin &gt; 0.5 | heat$Vancomycin &gt; 0.5) ),] # filter water heat &lt;- data.matrix(heat) library(circlize) library(ComplexHeatmap) heat[is.na(heat)] &lt;- 0 col_fun = colorRamp2(c(0, 0.5, 1), c(&quot;white&quot;, &quot;yellow&quot;, &quot;red&quot;)) Heatmap(heat, name = &quot;AF&quot;, col = col_fun, column_names_gp = gpar(fontsize = 9), row_names_max_width = unit(15, &quot;cm&quot;), row_names_gp = gpar(fontsize = 9), show_row_dend = F, show_row_names = T, show_column_dend = F ) 3.9.6 YL58 (Blautia coccoides) dat &lt;- readRDS(&quot;data/rds/reseq.rds&quot;) #dat &lt;- dat[which(dat$mouse.group == &quot;Water&quot; | dat$mouse.group == &quot;Tetracyclin&quot; ),] data.wide &lt;- dcast(dat, genome + POS + REF + ALT + feature ~ mouse.group, value.var = &quot;AF&quot;) ## Warning in dcast(dat, genome + POS + REF + ALT + feature ~ mouse.group, : The dcast generic in data.table ## has been passed a data.frame and will attempt to redirect to the reshape2::dcast; please note that ## reshape2 is deprecated, and this redirection is now deprecated as well. Please do this redirection ## yourself like reshape2::dcast(dat). In the next version, this warning will become an error. data.wide &lt;- data.wide[which(data.wide$genome == &quot;YL58&quot;),] rownames(data.wide) &lt;- paste0(data.wide$POS, &quot; (&quot;,data.wide$REF, &quot; -&gt; &quot;,data.wide$ALT, &quot;) &quot;, data.wide$feature) heat &lt;- data.wide[,6:9] heat[is.na(heat)] &lt;- 0 heat &lt;- heat[which(heat$Water &lt; 0.5 &amp; (heat$Ciprofloxacin &gt; 0.5 | heat$Tetracyclin &gt; 0.5 | heat$Vancomycin &gt; 0.5) ),] # filter water heat &lt;- data.matrix(heat) library(circlize) library(ComplexHeatmap) heat[is.na(heat)] &lt;- 0 col_fun = colorRamp2(c(0, 0.5, 1), c(&quot;white&quot;, &quot;yellow&quot;, &quot;red&quot;)) Heatmap(heat, name = &quot;AF&quot;, col = col_fun, column_names_gp = gpar(fontsize = 9), row_names_max_width = unit(15, &quot;cm&quot;), row_names_gp = gpar(fontsize = 9), show_row_dend = F, show_row_names = T, show_column_dend = F ) 3.9.7 I46 (Clostridium innocuum) dat &lt;- readRDS(&quot;data/rds/reseq.rds&quot;) #dat &lt;- dat[which(dat$mouse.group == &quot;Water&quot; | dat$mouse.group == &quot;Tetracyclin&quot; ),] data.wide &lt;- dcast(dat, genome + POS + REF + ALT + feature ~ mouse.group, value.var = &quot;AF&quot;) ## Warning in dcast(dat, genome + POS + REF + ALT + feature ~ mouse.group, : The dcast generic in data.table ## has been passed a data.frame and will attempt to redirect to the reshape2::dcast; please note that ## reshape2 is deprecated, and this redirection is now deprecated as well. Please do this redirection ## yourself like reshape2::dcast(dat). In the next version, this warning will become an error. data.wide &lt;- data.wide[which(data.wide$genome == &quot;I46&quot;),] rownames(data.wide) &lt;- paste0(data.wide$POS, &quot; (&quot;,data.wide$REF, &quot; -&gt; &quot;,data.wide$ALT, &quot;) &quot;, data.wide$feature) heat &lt;- data.wide[,6:9] heat[is.na(heat)] &lt;- 0 heat &lt;- heat[which(heat$Water &lt; 0.5 &amp; (heat$Ciprofloxacin &gt; 0.5 | heat$Tetracyclin &gt; 0.5 | heat$Vancomycin &gt; 0.5) ),] # filter water heat &lt;- data.matrix(heat) library(circlize) library(ComplexHeatmap) heat[is.na(heat)] &lt;- 0 col_fun = colorRamp2(c(0, 0.5, 1), c(&quot;white&quot;, &quot;yellow&quot;, &quot;red&quot;)) Heatmap(heat, name = &quot;AF&quot;, col = col_fun, column_names_gp = gpar(fontsize = 9), row_names_max_width = unit(10, &quot;cm&quot;), row_names_gp = gpar(fontsize = 9), show_row_dend = F, show_row_names = T, show_column_dend = F ) "],
["ab-effects-metagenomes.html", "Section 4 AB-effects (metagenomes) 4.1 Load in variants 4.2 add presence in reseq experiment 4.3 AF frequency 4.4 Average coverage of variants by genome 4.5 number of variants per samples 4.6 Heatmap 4.7 with information if SNP was observed in resequencing 4.8 Focus on mouse where we have many time points 4.9 Akkermansia Muciniphila", " Section 4 AB-effects (metagenomes) 4.1 Load in variants vcfToDataframe &lt;- function(vcf.files, contig_mapping = contig_mapping, gff.df = gff.df) { require(vcfR) res &lt;- list() for (file in vcf.files) { library(data.table) vcf.content &lt;- vcfR::read.vcfR(file, verbose = FALSE) vcf.fix &lt;- as.data.frame(vcf.content@fix) # contains chr, position and substitution informations vcf.info &lt;- vcfR::INFO2df(vcf.content) # get INFO field, contains DP, AF informations if (nrow(vcf.fix) &gt; 0) { # there are variants dat &lt;- as.data.frame(cbind(vcf.fix[, c(1, 2, 4, 5, 6)], vcf.info[, c(1, 2)])) dat$majorAF &lt;- sapply(dat$AF, minorAfToMajorAf) # transforms e.g. AF of 0.1 to 0.9, 0.9 stays 0.9 and 0.5 stays 0.5 dat$genome &lt;- contig_mapping[match(dat$CHROM, contig_mapping$contig), ]$genome # map chr information to genome name e.g. NHMU01000001.1 -&gt; i48 dat$genome_hr &lt;- translateGenomeIdToFullName(tolower(dat$genome)) dat$mouse.id &lt;- substr(tools::file_path_sans_ext(basename(file)), 1, 4) dat$mouse.group &lt;- translateMouseIdToTreatmentGroup(dat$mouse.id) dat$day &lt;- as.integer(substr(basename(file), 6, 7)) dat$phase &lt;- binDaysByPhase(as.numeric(as.matrix(dat$day))) dat$phase_num &lt;- binDaysByPhaseGroup(dat$day) dat$dp &lt;- as.numeric(as.matrix(vcf.info$DP)) # annotate overlay of gene dt.gff &lt;- data.table(start = gff.df$start, end = gff.df$end, chr = as.character(as.matrix(gff.df$chr)), feature = gff.df$product) colnames(dat)[1:2] &lt;- c(&quot;chr&quot;, &quot;start&quot;) dat$start &lt;- as.integer(as.matrix(dat$start)) dat$chr &lt;- as.character(as.matrix(dat$chr)) dat$end &lt;- dat$start dat2 &lt;- as.data.table(dat) setkey(dt.gff, chr, start, end) annotated &lt;- foverlaps(dat2, dt.gff, type = &quot;within&quot;, mult = &quot;first&quot;) res[[tools::file_path_sans_ext(basename(file))]] &lt;- annotated # add vcf df to list } else { message(paste(&quot;Skipping&quot;, file)) } } df &lt;- as.data.frame(do.call(rbind, res)) # merge list to df return(df) } # load in reference information gff.files &lt;- Sys.glob(&quot;data/references/joined_reference_curated_ecoli/*.gff&quot;) gff.df &lt;- NULL for (gff.file in gff.files) { message(gff.file) gff &lt;- rtracklayer::readGFF(gff.file) # subset since different columns are present on gff files relevant &lt;- data.frame(start = gff$start, end = gff$end, type = as.character(as.matrix(gff$type)), gene = as.character(as.matrix(gff$gene)), product = as.character(as.matrix(gff$product)), chr = as.character(as.matrix(gff$seqid))) relevant$genome &lt;- substr(basename(gff.file), 1, nchar(basename(gff.file)) - 4) gff.df &lt;- rbind(gff.df, relevant) } ## data/references/joined_reference_curated_ecoli/joined_reference_curated_ecoli.gff # load in contig information contig_mapping &lt;- read.csv2(&quot;data/contig_mapping_new_ref.csv&quot;, sep = &quot;;&quot;, header = T, stringsAsFactors = F) # this file contains contig names of the 12 OligoMM genomes # load in vcf files vcf.files &lt;- Sys.glob(&quot;out_philipp/all_vcf/*.vcf&quot;) vcf.samples &lt;- suppressWarnings(vcfToDataframe(vcf.files, contig_mapping, gff.df = gff.df)) ## Skipping out_philipp/all_vcf/1683d09_S49.vcf vcf.samples$feature &lt;- as.character(as.matrix(vcf.samples$feature)) vcf.samples[which(is.na(vcf.samples$feature)), ]$feature &lt;- &quot;outside ORFs&quot; vcf.samples$start &lt;- NULL vcf.samples$end &lt;- NULL vcf.samples$i.end &lt;- NULL colnames(vcf.samples)[3] &lt;- &quot;POS&quot; vcf.samples$ref_size &lt;- nchar(as.character(as.matrix(vcf.samples$REF))) vcf.samples$alt_size &lt;- nchar(as.character(as.matrix(vcf.samples$ALT))) vcf.samples$alteration &lt;- paste(as.character(vcf.samples$REF), &quot;-&gt;&quot;, as.character(vcf.samples$ALT)) vcf.samples$alteration_type &lt;- &quot;SNP&quot; vcf.samples[which(vcf.samples$ref_size &lt; vcf.samples$alt_size), ]$alteration_type &lt;- &quot;insertion&quot; vcf.samples[which(vcf.samples$ref_size &gt; vcf.samples$alt_size), ]$alteration_type &lt;- &quot;deletion&quot; saveRDS(vcf.samples, file = &quot;data/rds/omm_ab.rds&quot;) 4.2 add presence in reseq experiment load in variants from resequencing run and mark if the variants form this study overlap dat &lt;- readRDS(&quot;data/rds/omm_ab.rds&quot;) dat_re &lt;- readRDS(&quot;data/rds/reseq.rds&quot;) dat_re$variant.id &lt;- paste(dat_re$chr, dat_re$POS, dat_re$REF, dat_re$ALT, sep = &quot;-&quot;) # consiger there if AF is &gt; .5 dat_re &lt;- dat_re[which(dat_re$AF &gt; 0.5), ] Save as table dat &lt;- readRDS(&quot;data/rds/omm_ab.rds&quot;) write.table(vcf_samples, file = &quot;results/tables/omm_antibiotic_variants_long.csv&quot;, sep = &quot;;&quot;, col.names = T, row.names = F, quote = F) dat$variant.id &lt;- paste(dat$chr, dat$POS, dat$REF, dat$ALT, sep = &quot;-&quot;) dat$fixed &lt;- FALSE dat[which(!is.na(match(dat$variant.id, dat_re$variant.id))), ]$fixed &lt;- TRUE saveRDS(dat, file = &quot;data/rds/omm_ab_with_fixed.rds&quot;) 4.3 AF frequency p &lt;- ggplot(vcf.samples, aes(AF, fill = genome)) + geom_histogram() p &lt;- p + facet_grid(mouse.id + mouse.group ~ genome + genome_hr) p &lt;- p + theme_classic() + xlab(&quot;AF&quot;) + ylab(&quot;occurence&quot;) print(p) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Figure 4.1: AF of resequenced strains p &lt;- ggplot(vcf.samples, aes(majorAF, fill = genome)) + geom_histogram() p &lt;- p + facet_grid(mouse.id + mouse.group ~ genome + genome_hr) p &lt;- p + theme_classic() + xlab(&quot;AF&quot;) + ylab(&quot;occurence&quot;) print(p) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Figure 4.2: major AF of resequenced strains 4.4 Average coverage of variants by genome dat &lt;- readRDS(&quot;data/rds/omm_ab.rds&quot;) dat_subset &lt;- dat[which(dat$mouse.group == &quot;Water&quot;), ] p &lt;- ggplot(dat_subset, aes(x = reorder(genome, -DP), y = DP, color = genome)) + geom_boxplot() p &lt;- p + theme_classic() + xlab(&quot;AF&quot;) + ylab(&quot;depth of variant&quot;) p &lt;- p + scale_y_log10() print(p) 4.5 number of variants per samples dat &lt;- readRDS(&quot;data/rds/omm_ab.rds&quot;) dat$dummy &lt;- 1 dat.agg &lt;- aggregate(dummy ~ mouse.id + mouse.group + day + phase, dat, sum) DT::datatable(dat.agg) 4.5.1 number of variants per treatment group p &lt;- ggplot(dat.agg, aes(x = mouse.id, y = dummy, color = day)) p &lt;- p + geom_jitter(shape = 4) + facet_grid(. ~ mouse.group, scales = &quot;free_x&quot;) p &lt;- p + geom_boxplot() + theme_classic() + xlab(&quot;Mouse ID&quot;) + ylab(&quot;number of variants&quot;) plotly::ggplotly(p) Figure 4.3: number of variants of all 12 OMM genomes by mouse 4.6 Heatmap All mice dat &lt;- readRDS(&quot;data/rds/omm_ab.rds&quot;) dat$sample.id &lt;- paste0(dat$mouse.id, &quot;-&quot;, dat$day) dat$variant.id &lt;- paste0(dat$POS, &quot;-&quot;, dat$REF, &quot;-&quot;, dat$ALT) data.wide &lt;- dcast(dat, variant.id ~ sample.id, value.var = &quot;AF&quot;) ## Warning in dcast(dat, variant.id ~ sample.id, value.var = &quot;AF&quot;): The dcast generic in data.table has ## been passed a data.frame and will attempt to redirect to the reshape2::dcast; please note that reshape2 ## is deprecated, and this redirection is now deprecated as well. Please do this redirection yourself like ## reshape2::dcast(dat). In the next version, this warning will become an error. data.wide[is.na(data.wide)] &lt;- 0 rownames(data.wide) &lt;- data.wide$variant.id data.wide$variant.id &lt;- NULL library(circlize) library(ComplexHeatmap) heat &lt;- data.matrix(data.wide) # limit to variants that are present in at least 10% of samples heat_num &lt;- rowSums(heat != 0) heat2 &lt;- heat[which(heat_num &gt; ncol(heat)/10), ] # limit to variants that have a high variance heat_var_num &lt;- matrixStats::rowVars(heat2) heat3 &lt;- heat2[which(heat_var_num &gt; quantile(heat_var_num, 0.5)), ] dat$dummy &lt;- 1 annot.data &lt;- aggregate(dummy ~ mouse.id + mouse.group + day + phase, dat, sum) annot.data$sample.id &lt;- paste0(annot.data$mouse.id, &quot;-&quot;, annot.data$day) heat3.mouse.id &lt;- annot.data[match(colnames(heat3), annot.data$sample.id), ]$mouse.id heat3.day &lt;- annot.data[match(colnames(heat3), annot.data$sample.id), ]$day heat3.mouse.group &lt;- annot.data[match(colnames(heat3), annot.data$sample.id), ]$mouse.group heat3.phase &lt;- annot.data[match(colnames(heat3), annot.data$sample.id), ]$phase heat3.phase2 &lt;- ifelse(heat3.phase == &quot;post-treatment&quot;, 6, NA) ord = data.frame(day = heat3.day, mouse.id = heat3.mouse.id) occ = as.data.frame(table(heat3.mouse.id)) ord$occ &lt;- occ[match(ord$mouse.id, occ$heat3.mouse.id), ]$Freq data.wide.sub &lt;- dat[match(colnames(heat3), dat$sample.id), ] col_fun = colorRamp2(c(0, 0.5, 1), c(&quot;white&quot;, &quot;yellow&quot;, &quot;red&quot;)) qpcr &lt;- read.table(&quot;qpcr.csv&quot;, header = T, sep = &quot;;&quot;) qpcr$universal &lt;- NULL rownames(qpcr) &lt;- paste0(qpcr$mouse, &quot;-&quot;, qpcr$day) qpcr &lt;- qpcr[, -c(1:5)] qpcr &lt;- apply(qpcr, 1, function(x) x/sum(x)) qpcr &lt;- qpcr[, which(colnames(qpcr) %in% colnames(heat3))] qpcr &lt;- qpcr[, match(colnames(heat3), colnames(qpcr))] # pdf(&#39;heat.pdf&#39;, width= 10, height = 10) Heatmap(heat3, name = &quot;AF&quot;, col = col_fun, border = TRUE, top_annotation = HeatmapAnnotation(num = anno_lines(colSums(heat3), smooth = TRUE, border = TRUE), ra = anno_barplot(t(qpcr), bar_width = 1, gp = gpar(fill = 1:12), height = unit(3, &quot;cm&quot;)), mouse = heat3.mouse.id, group = heat3.mouse.group, phase = heat3.phase, day = anno_simple(heat3.day, pch = heat3.phase2)), cluster_columns = F, column_order = order(ord$occ, ord$mouse.id, ord$day), right_annotation = rowAnnotation(prev = anno_barplot(rowSums(heat3))), row_gap = unit(0, &quot;mm&quot;), column_gap = unit(0, &quot;mm&quot;), column_split = heat3.mouse.group, column_names_gp = gpar(fontsize = 5), row_names_gp = gpar(fontsize = 3), show_row_dend = F, show_row_names = F, show_column_dend = F) # dev.off() 4.7 with information if SNP was observed in resequencing all high-variant dat &lt;- readRDS(&quot;data/rds/omm_ab_with_fixed.rds&quot;) dat$sample.id &lt;- paste0(dat$mouse.id, &quot;-&quot;, dat$day) dat$variant.id &lt;- paste0(dat$genome_hr, &quot;-&quot;, dat$fixed, &quot;-&quot;, dat$POS, &quot;-&quot;, dat$REF, &quot;-&quot;, dat$ALT) data.wide &lt;- dcast(dat, variant.id ~ sample.id, value.var = &quot;AF&quot;) ## Warning in dcast(dat, variant.id ~ sample.id, value.var = &quot;AF&quot;): The dcast generic in data.table has ## been passed a data.frame and will attempt to redirect to the reshape2::dcast; please note that reshape2 ## is deprecated, and this redirection is now deprecated as well. Please do this redirection yourself like ## reshape2::dcast(dat). In the next version, this warning will become an error. data.wide[is.na(data.wide)] &lt;- 0 rownames(data.wide) &lt;- data.wide$variant.id data.wide$variant.id &lt;- NULL library(circlize) library(ComplexHeatmap) heat &lt;- data.matrix(data.wide) # limit to variants that are present in at least 10% of samples heat_num &lt;- rowSums(heat != 0) heat2 &lt;- heat[which(heat_num &gt; ncol(heat)/10), ] # limit to variants that have a high variance heat_var_num &lt;- matrixStats::rowVars(heat2) heat3 &lt;- heat2[which(heat_var_num &gt; quantile(heat_var_num, 0.5)), ] dat$dummy &lt;- 1 annot.data &lt;- aggregate(dummy ~ mouse.id + mouse.group + day + phase, dat, sum) annot.data$sample.id &lt;- paste0(annot.data$mouse.id, &quot;-&quot;, annot.data$day) heat3.mouse.id &lt;- annot.data[match(colnames(heat3), annot.data$sample.id), ]$mouse.id heat3.day &lt;- annot.data[match(colnames(heat3), annot.data$sample.id), ]$day heat3.mouse.group &lt;- annot.data[match(colnames(heat3), annot.data$sample.id), ]$mouse.group heat3.phase &lt;- annot.data[match(colnames(heat3), annot.data$sample.id), ]$phase heat3.phase2 &lt;- ifelse(heat3.phase == &quot;post-treatment&quot;, 6, NA) ord = data.frame(day = heat3.day, mouse.id = heat3.mouse.id) occ = as.data.frame(table(heat3.mouse.id)) ord$occ &lt;- occ[match(ord$mouse.id, occ$heat3.mouse.id), ]$Freq data.wide.sub &lt;- dat[match(colnames(heat3), dat$sample.id), ] col_fun = colorRamp2(c(0, 0.5, 1), c(&quot;white&quot;, &quot;yellow&quot;, &quot;red&quot;)) qpcr &lt;- read.table(&quot;qpcr.csv&quot;, header = T, sep = &quot;;&quot;) qpcr$universal &lt;- NULL rownames(qpcr) &lt;- paste0(qpcr$mouse, &quot;-&quot;, qpcr$day) qpcr &lt;- qpcr[, -c(1:5)] qpcr &lt;- apply(qpcr, 1, function(x) x/sum(x)) qpcr &lt;- qpcr[, which(colnames(qpcr) %in% colnames(heat3))] qpcr &lt;- qpcr[, match(colnames(heat3), colnames(qpcr))] bug &lt;- sapply(strsplit(rownames(heat3), split = &quot;-&quot;, fixed = TRUE), `[`, 1) fixed &lt;- sapply(strsplit(rownames(heat3), split = &quot;-&quot;, fixed = TRUE), `[`, 2) pdf(&quot;heat.pdf&quot;, width = 10, height = 10) Heatmap(heat3, name = &quot;AF&quot;, col = col_fun, border = TRUE, top_annotation = HeatmapAnnotation(num = anno_lines(colSums(heat3), smooth = TRUE, border = TRUE), ra = anno_barplot(t(qpcr), bar_width = 1, gp = gpar(fill = 1:12), height = unit(3, &quot;cm&quot;)), mouse = heat3.mouse.id, group = heat3.mouse.group, phase = heat3.phase, day = anno_simple(heat3.day, pch = heat3.phase2)), cluster_columns = F, column_order = order(ord$occ, ord$mouse.id, ord$day), right_annotation = rowAnnotation(fixed = fixed, bug = bug, prev = anno_barplot(rowSums(heat3)), col = bugcolors), row_gap = unit(0, &quot;mm&quot;), column_gap = unit(0, &quot;mm&quot;), column_split = heat3.mouse.group, column_names_gp = gpar(fontsize = 5), row_names_gp = gpar(fontsize = 3), show_row_dend = F, show_row_names = F, show_column_dend = F) dev.off() ## quartz ## 2 All that are fixed dat &lt;- readRDS(&quot;data/rds/omm_ab_with_fixed.rds&quot;) dat &lt;- dat[which(dat$fixed == TRUE),] dat$sample.id &lt;- paste0(dat$mouse.id, &quot;-&quot;,dat$day) dat$variant.id &lt;- paste0(dat$genome_hr,&quot;-&quot;, dat$fixed, &quot;-&quot;, dat$POS, &quot;-&quot;, dat$REF, &quot;-&quot;, dat$ALT) data.wide &lt;- dcast(dat, variant.id ~ sample.id, value.var = &quot;AF&quot;) data.wide[is.na(data.wide)] &lt;- 0 rownames(data.wide) &lt;- data.wide$variant.id data.wide$variant.id &lt;- NULL library(circlize) library(ComplexHeatmap) heat &lt;- data.matrix(data.wide) # limit to variants that are present in at least 10% of samples heat_num &lt;- rowSums(heat != 0) heat2 &lt;- heat[which(heat_num &gt; ncol(heat)/10),] # limit to variants that have a high variance heat_var_num &lt;- matrixStats::rowVars(heat2) heat3 &lt;- heat2[which(heat_var_num &gt; quantile(heat_var_num, 0.5)) ,] heat3 &lt;- heat dat$dummy &lt;- 1 annot.data &lt;- aggregate(dummy ~ mouse.id + mouse.group + day + phase, dat, sum) annot.data$sample.id &lt;- paste0(annot.data$mouse.id, &quot;-&quot;,annot.data$day) heat3.mouse.id &lt;- annot.data[match(colnames(heat3), annot.data$sample.id),]$mouse.id heat3.day &lt;- annot.data[match(colnames(heat3), annot.data$sample.id),]$day heat3.mouse.group &lt;- annot.data[match(colnames(heat3), annot.data$sample.id),]$mouse.group heat3.phase &lt;- annot.data[match(colnames(heat3), annot.data$sample.id),]$phase heat3.phase2 &lt;- ifelse(heat3.phase == &quot;post-treatment&quot;, 6, NA) ord = data.frame(day = heat3.day, mouse.id =heat3.mouse.id ) occ = as.data.frame(table(heat3.mouse.id)) ord$occ &lt;- occ[match(ord$mouse.id, occ$heat3.mouse.id),]$Freq data.wide.sub &lt;- dat[match(colnames(heat3), dat$sample.id),] col_fun = colorRamp2(c(0, 0.5, 1), c(&quot;white&quot;, &quot;yellow&quot;, &quot;red&quot;)) qpcr &lt;- read.table(&quot;qpcr.csv&quot;, header = T, sep = &quot;;&quot;) qpcr$universal &lt;- NULL rownames(qpcr) &lt;- paste0(qpcr$mouse, &quot;-&quot;,qpcr$day) qpcr &lt;- qpcr[,-c(1:5)] qpcr &lt;- apply(qpcr, 1, function(x) x/sum(x)) qpcr &lt;- qpcr[,which(colnames(qpcr) %in% colnames(heat3))] qpcr &lt;- qpcr[,match(colnames(heat3), colnames(qpcr))] bug &lt;- sapply(strsplit(rownames(heat3), split=&#39;-&#39;, fixed=TRUE), `[`, 1) fixed &lt;- sapply(strsplit(rownames(heat3), split=&#39;-&#39;, fixed=TRUE), `[`, 2) Heatmap(heat3, name = &quot;AF&quot;, col = col_fun, border = TRUE, column_order = order(ord$occ, ord$mouse.id, ord$day),cluster_columns =F, right_annotation = rowAnnotation(fixed = fixed, bug = bug, prev = anno_barplot(rowSums(heat3)), col = bugcolors), row_gap = unit(0, &quot;mm&quot;), column_gap = unit(0, &quot;mm&quot;), top_annotation = HeatmapAnnotation(num = anno_lines(colSums(heat3), smooth = TRUE,border = TRUE), ra = anno_barplot(t(qpcr), bar_width = 1,gp = gpar(fill = 1:12), height = unit(3, &quot;cm&quot;)), mouse = heat3.mouse.id, group = heat3.mouse.group, phase = heat3.phase, day=anno_simple(heat3.day, pch =heat3.phase2)), column_names_gp = gpar(fontsize =5), row_names_gp = gpar(fontsize = 3), show_row_dend = F, show_row_names = F, show_column_dend = F ) All mice clustered dat &lt;- readRDS(&quot;data/rds/omm_ab.rds&quot;) dat$sample.id &lt;- paste0(dat$mouse.id, &quot;-&quot;, dat$day) dat$variant.id &lt;- paste0(dat$POS, &quot;-&quot;, dat$REF, &quot;-&quot;, dat$ALT) data.wide &lt;- dcast(dat, variant.id ~ sample.id, value.var = &quot;AF&quot;) ## Warning in dcast(dat, variant.id ~ sample.id, value.var = &quot;AF&quot;): The dcast generic in data.table has ## been passed a data.frame and will attempt to redirect to the reshape2::dcast; please note that reshape2 ## is deprecated, and this redirection is now deprecated as well. Please do this redirection yourself like ## reshape2::dcast(dat). In the next version, this warning will become an error. data.wide[is.na(data.wide)] &lt;- 0 rownames(data.wide) &lt;- data.wide$variant.id data.wide$variant.id &lt;- NULL library(circlize) library(ComplexHeatmap) heat &lt;- data.matrix(data.wide) # limit to variants that are present in at least 10% of samples heat_num &lt;- rowSums(heat != 0) heat2 &lt;- heat[which(heat_num &gt; ncol(heat)/10), ] # limit to variants that have a high variance heat_var_num &lt;- matrixStats::rowVars(heat2) heat3 &lt;- heat2[which(heat_var_num &gt; quantile(heat_var_num, 0.5)), ] dat$dummy &lt;- 1 annot.data &lt;- aggregate(dummy ~ mouse.id + mouse.group + day + phase, dat, sum) annot.data$sample.id &lt;- paste0(annot.data$mouse.id, &quot;-&quot;, annot.data$day) heat3.mouse.id &lt;- annot.data[match(colnames(heat3), annot.data$sample.id), ]$mouse.id heat3.day &lt;- annot.data[match(colnames(heat3), annot.data$sample.id), ]$day heat3.mouse.group &lt;- annot.data[match(colnames(heat3), annot.data$sample.id), ]$mouse.group heat3.phase &lt;- annot.data[match(colnames(heat3), annot.data$sample.id), ]$phase heat3.phase2 &lt;- ifelse(heat3.phase == &quot;post-treatment&quot;, 6, NA) ord = data.frame(day = heat3.day, mouse.id = heat3.mouse.id) occ = as.data.frame(table(heat3.mouse.id)) ord$occ &lt;- occ[match(ord$mouse.id, occ$heat3.mouse.id), ]$Freq data.wide.sub &lt;- dat[match(colnames(heat3), dat$sample.id), ] col_fun = colorRamp2(c(0, 0.5, 1), c(&quot;white&quot;, &quot;yellow&quot;, &quot;red&quot;)) qpcr &lt;- read.table(&quot;qpcr.csv&quot;, header = T, sep = &quot;;&quot;) qpcr$universal &lt;- NULL rownames(qpcr) &lt;- paste0(qpcr$mouse, &quot;-&quot;, qpcr$day) qpcr &lt;- qpcr[, -c(1:5)] qpcr &lt;- apply(qpcr, 1, function(x) x/sum(x)) qpcr &lt;- qpcr[, which(colnames(qpcr) %in% colnames(heat3))] qpcr &lt;- qpcr[, match(colnames(heat3), colnames(qpcr))] # pdf(&#39;heat.pdf&#39;, width= 10, height = 10) Heatmap(heat3, name = &quot;AF&quot;, col = col_fun, border = TRUE, top_annotation = HeatmapAnnotation(num = anno_lines(colSums(heat3), smooth = TRUE, border = TRUE), ra = anno_barplot(t(qpcr), bar_width = 1, gp = gpar(fill = 1:12), height = unit(3, &quot;cm&quot;)), mouse = heat3.mouse.id, group = heat3.mouse.group, phase = heat3.phase, day = anno_simple(heat3.day, pch = heat3.phase2)), cluster_columns = T, right_annotation = rowAnnotation(prev = anno_barplot(rowSums(heat3))), row_gap = unit(0, &quot;mm&quot;), column_gap = unit(0, &quot;mm&quot;), column_names_gp = gpar(fontsize = 5), row_names_gp = gpar(fontsize = 3), show_row_dend = F, show_row_names = F, show_column_dend = T) # dev.off() dat &lt;- readRDS(&quot;data/rds/omm_ab.rds&quot;) dat$sample.id &lt;- paste0(dat$mouse.id, &quot;-&quot;, dat$day) dat$variant.id &lt;- paste0(dat$POS, &quot;-&quot;, dat$REF, &quot;-&quot;, dat$ALT) data.wide &lt;- dcast(dat, variant.id ~ sample.id, value.var = &quot;AF&quot;) ## Warning in dcast(dat, variant.id ~ sample.id, value.var = &quot;AF&quot;): The dcast generic in data.table has ## been passed a data.frame and will attempt to redirect to the reshape2::dcast; please note that reshape2 ## is deprecated, and this redirection is now deprecated as well. Please do this redirection yourself like ## reshape2::dcast(dat). In the next version, this warning will become an error. data.wide[is.na(data.wide)] &lt;- 0 rownames(data.wide) &lt;- data.wide$variant.id data.wide$variant.id &lt;- NULL library(circlize) library(ComplexHeatmap) heat &lt;- data.matrix(data.wide) # limit to variants that are present in at least 10% of samples heat_num &lt;- rowSums(heat != 0) heat2 &lt;- heat[which(heat_num &gt; ncol(heat)/10), ] # limit to variants that have a high variance heat_var_num &lt;- matrixStats::rowVars(heat2) heat3 &lt;- heat2[which(heat_var_num &gt; quantile(heat_var_num, 0.5)), ] dat$dummy &lt;- 1 annot.data &lt;- aggregate(dummy ~ mouse.id + mouse.group + day + phase, dat, sum) annot.data$sample.id &lt;- paste0(annot.data$mouse.id, &quot;-&quot;, annot.data$day) heat3.mouse.id &lt;- annot.data[match(colnames(heat3), annot.data$sample.id), ]$mouse.id heat3.day &lt;- annot.data[match(colnames(heat3), annot.data$sample.id), ]$day heat3.mouse.group &lt;- annot.data[match(colnames(heat3), annot.data$sample.id), ]$mouse.group heat3.phase &lt;- annot.data[match(colnames(heat3), annot.data$sample.id), ]$phase heat3.phase2 &lt;- ifelse(heat3.phase == &quot;post-treatment&quot;, 6, NA) ord = data.frame(day = heat3.day, mouse.id = heat3.mouse.id) occ = as.data.frame(table(heat3.mouse.id)) ord$occ &lt;- occ[match(ord$mouse.id, occ$heat3.mouse.id), ]$Freq data.wide.sub &lt;- dat[match(colnames(heat3), dat$sample.id), ] col_fun = colorRamp2(c(0, 0.5, 1), c(&quot;white&quot;, &quot;yellow&quot;, &quot;red&quot;)) qpcr &lt;- read.table(&quot;qpcr.csv&quot;, header = T, sep = &quot;;&quot;) qpcr$universal &lt;- NULL rownames(qpcr) &lt;- paste0(qpcr$mouse, &quot;-&quot;, qpcr$day) qpcr &lt;- qpcr[, -c(1:5)] qpcr &lt;- t(qpcr) qpcr &lt;- qpcr[, which(colnames(qpcr) %in% colnames(heat3))] qpcr &lt;- qpcr[, match(colnames(heat3), colnames(qpcr))] # pdf(&#39;heat.pdf&#39;, width= 10, height = 10) Heatmap(heat3, name = &quot;AF&quot;, col = col_fun, border = TRUE, top_annotation = HeatmapAnnotation(num = anno_lines(colSums(heat3), smooth = TRUE, border = TRUE), ra = anno_barplot(t(qpcr), bar_width = 1, gp = gpar(fill = 1:12), height = unit(3, &quot;cm&quot;)), mouse = heat3.mouse.id, group = heat3.mouse.group, phase = heat3.phase, day = anno_simple(heat3.day, pch = heat3.phase2)), cluster_columns = T, right_annotation = rowAnnotation(prev = anno_barplot(rowSums(heat3))), row_gap = unit(0, &quot;mm&quot;), column_gap = unit(0, &quot;mm&quot;), column_names_gp = gpar(fontsize = 5), row_names_gp = gpar(fontsize = 3), show_row_dend = F, show_row_names = F, show_column_dend = T) # dev.off() 4.8 Focus on mouse where we have many time points dat &lt;- readRDS(&quot;data/rds/omm_ab.rds&quot;) dat$rep.group &lt;- translateMouseIdToReplicateGroup(dat$mouse.id) dat &lt;- dat[which(dat$rep.group == &quot;Full&quot;), ] dat$sample.id &lt;- paste0(dat$mouse.id, &quot;-&quot;, dat$day) dat$variant.id &lt;- paste0(dat$POS, &quot;-&quot;, dat$REF, &quot;-&quot;, dat$ALT) data.wide &lt;- dcast(dat, variant.id ~ sample.id, value.var = &quot;AF&quot;) ## Warning in dcast(dat, variant.id ~ sample.id, value.var = &quot;AF&quot;): The dcast generic in data.table has ## been passed a data.frame and will attempt to redirect to the reshape2::dcast; please note that reshape2 ## is deprecated, and this redirection is now deprecated as well. Please do this redirection yourself like ## reshape2::dcast(dat). In the next version, this warning will become an error. data.wide[is.na(data.wide)] &lt;- 0 rownames(data.wide) &lt;- data.wide$variant.id data.wide$variant.id &lt;- NULL heat &lt;- data.matrix(data.wide) # limit to variants that are present in at least 10% of samples heat_num &lt;- rowSums(heat != 0) heat2 &lt;- heat[which(heat_num &gt; ncol(heat)/10), ] # limit to variants that have a high variance heat_var_num &lt;- matrixStats::rowVars(heat2) heat3 &lt;- heat2[which(heat_var_num &gt; quantile(heat_var_num, 0.5)), ] dat$dummy &lt;- 1 annot.data &lt;- aggregate(dummy ~ mouse.id + mouse.group + day + phase, dat, sum) annot.data$sample.id &lt;- paste0(annot.data$mouse.id, &quot;-&quot;, annot.data$day) heat3.mouse.id &lt;- annot.data[match(colnames(heat3), annot.data$sample.id), ]$mouse.id heat3.day &lt;- annot.data[match(colnames(heat3), annot.data$sample.id), ]$day ord = data.frame(day = heat3.day, mouse.id = heat3.mouse.id) heat3.mouse.group &lt;- annot.data[match(colnames(heat3), annot.data$sample.id), ]$mouse.group heat3.phase &lt;- annot.data[match(colnames(heat3), annot.data$sample.id), ]$phase heat3.phase2 &lt;- ifelse(heat3.phase == &quot;post-treatment&quot;, 6, NA) col_fun = colorRamp2(c(0, 0.5, 1), c(&quot;white&quot;, &quot;yellow&quot;, &quot;red&quot;)) # order the heatmap by treatment group Heatmap(heat3, name = &quot;AF&quot;, col = col_fun, border = TRUE, top_annotation = HeatmapAnnotation(num = anno_lines(colSums(heat3), smooth = TRUE, border = TRUE), day = anno_simple(heat3.day, pch = heat3.phase2)), cluster_columns = F, column_order = order(ord$mouse.id, ord$day), column_split = heat3.mouse.group, column_names_gp = gpar(fontsize = 5), row_names_gp = gpar(fontsize = 8), show_row_dend = F, show_row_names = F, show_column_dend = F) 4.9 Akkermansia Muciniphila 4.9.1 area plot 1 dat &lt;- readRDS(&quot;data/rds/omm_ab.rds&quot;) dat$variant.id &lt;- paste0(dat$POS, &quot;-&quot;, dat$REF, &quot;-&quot;, dat$ALT) dat &lt;- dat[which(dat$chr == &quot;Akkermansia_muciniphila&quot;), ] data.wide &lt;- dcast(dat, day + mouse.id + mouse.group ~ variant.id, value.var = &quot;AF&quot;) ## Warning in dcast(dat, day + mouse.id + mouse.group ~ variant.id, value.var = &quot;AF&quot;): The dcast generic in ## data.table has been passed a data.frame and will attempt to redirect to the reshape2::dcast; please note ## that reshape2 is deprecated, and this redirection is now deprecated as well. Please do this redirection ## yourself like reshape2::dcast(dat). In the next version, this warning will become an error. data.wide[is.na(data.wide)] &lt;- 0 colMax &lt;- function(X) apply(X, 2, max) dat_mat &lt;- data.wide[, -c(1:3)] # filter variants data.wide.reduced &lt;- cbind(data.wide[, c(1:3)], dat_mat[, which(colMax(dat_mat) &gt; 0.5)]) # data.wide.reduced &lt;- data.wide dat2 &lt;- melt(data.wide.reduced, id.vars = c(&quot;day&quot;, &quot;mouse.id&quot;, &quot;mouse.group&quot;)) ## Warning in melt(data.wide.reduced, id.vars = c(&quot;day&quot;, &quot;mouse.id&quot;, &quot;mouse.group&quot;)): The melt generic in ## data.table has been passed a data.frame and will attempt to redirect to the relevant reshape2 method; ## please note that reshape2 is deprecated, and this redirection is now deprecated as well. To continue ## using melt methods from reshape2 while both libraries are attached, e.g. melt.list, you can prepend the ## namespace like reshape2::melt(data.wide.reduced). In the next version, this warning will become an error. dat3 &lt;- dat2 %&gt;% group_by(day, mouse.id) %&gt;% mutate(Nor = value/sum(value)) set.seed(123) col_list &lt;- sort(unique(dat3$variable)) cols &lt;- randomcoloR::randomColor(length(unique(dat3$variable))) # Muller plot p &lt;- ggplot(dat3, aes(x = day, y = Nor, group = variable, fill = variable, label = )) p &lt;- p + geom_area(color = &quot;black&quot;, size = 0.1) p &lt;- p + facet_wrap(~mouse.group + mouse.id, ncol = 3) p &lt;- p + theme_minimal() + theme(legend.position = &quot;none&quot;) p &lt;- p + ylab(&quot;Fraction&quot;) p &lt;- p + scale_fill_manual(values = cols, breaks = col_list) p &lt;- p + geom_vline(xintercept = c(4, 18, 53, 67)) plotly::ggplotly(p) 4.9.2 line plot dat &lt;- readRDS(&quot;data/rds/omm_ab.rds&quot;) dat$variant.id &lt;- paste0(dat$POS, &quot;-&quot;, dat$REF, &quot;-&quot;, dat$ALT) dat &lt;- dat[which(dat$chr == &quot;Akkermansia_muciniphila&quot;), ] data.wide &lt;- dcast(dat, day + mouse.id + mouse.group ~ variant.id, value.var = &quot;AF&quot;) ## Warning in dcast(dat, day + mouse.id + mouse.group ~ variant.id, value.var = &quot;AF&quot;): The dcast generic in ## data.table has been passed a data.frame and will attempt to redirect to the reshape2::dcast; please note ## that reshape2 is deprecated, and this redirection is now deprecated as well. Please do this redirection ## yourself like reshape2::dcast(dat). In the next version, this warning will become an error. data.wide[is.na(data.wide)] &lt;- 0 dat2 &lt;- melt(data.wide, id.vars = c(&quot;day&quot;, &quot;mouse.id&quot;, &quot;mouse.group&quot;)) ## Warning in melt(data.wide, id.vars = c(&quot;day&quot;, &quot;mouse.id&quot;, &quot;mouse.group&quot;)): The melt generic in data.table ## has been passed a data.frame and will attempt to redirect to the relevant reshape2 method; please note ## that reshape2 is deprecated, and this redirection is now deprecated as well. To continue using melt ## methods from reshape2 while both libraries are attached, e.g. melt.list, you can prepend the namespace ## like reshape2::melt(data.wide). In the next version, this warning will become an error. set.seed(123) col_list &lt;- sort(unique(dat3$variable)) cols &lt;- randomcoloR::randomColor(length(unique(dat3$variable))) p &lt;- ggplot(dat2, aes(x = day, y = value)) p &lt;- p + geom_line(aes(group = variable), alpha = 0.2) p &lt;- p + theme_minimal() p &lt;- p + facet_wrap(~mouse.group + mouse.id, ncol = 3) p &lt;- p + geom_vline(xintercept = c(4, 18, 53, 67)) plotly::ggplotly(p) "],
["dendogram.html", "Section 5 dendogram", " Section 5 dendogram library(circlize) library(ComplexHeatmap) dat &lt;- readRDS(&quot;data/rds/omm_ab_with_fixed.rds&quot;) dat$rep.group &lt;- translateMouseIdToReplicateGroup(dat$mouse.id) dat &lt;- dat[which(dat$rep.group == &quot;Full&quot;), ] dat$sample.id &lt;- paste0(dat$mouse.id, &quot;-&quot;, dat$day) dat$variant.id &lt;- paste0(dat$genome_hr, &quot;-&quot;, dat$fixed, &quot;-&quot;, dat$POS, &quot;-&quot;, dat$REF, &quot;-&quot;, dat$ALT) data.wide &lt;- dcast(dat, variant.id ~ sample.id, value.var = &quot;AF&quot;) data.wide[is.na(data.wide)] &lt;- 0 rownames(data.wide) &lt;- data.wide$variant.id data.wide$variant.id &lt;- NULL heat &lt;- data.matrix(data.wide) # limit to variants that are present in at least 10% of samples heat_num &lt;- rowSums(heat != 0) # limit to variants that have a high variance heat2 &lt;- heat heat_var_num &lt;- matrixStats::rowVars(heat2) heat3 &lt;- heat dat$dummy &lt;- 1 annot.data &lt;- aggregate(dummy ~ mouse.id + mouse.group + day + phase, dat, sum) annot.data$sample.id &lt;- paste0(annot.data$mouse.id, &quot;-&quot;, annot.data$day) heat3.mouse.id &lt;- annot.data[match(colnames(heat3), annot.data$sample.id), ]$mouse.id heat3.day &lt;- annot.data[match(colnames(heat3), annot.data$sample.id), ]$day heat3.mouse.group &lt;- annot.data[match(colnames(heat3), annot.data$sample.id), ]$mouse.group heat3.phase &lt;- annot.data[match(colnames(heat3), annot.data$sample.id), ]$phase heat3.phase2 &lt;- ifelse(heat3.phase == &quot;post-treatment&quot;, 6, NA) ord = data.frame(day = heat3.day, mouse.id = heat3.mouse.id) occ = as.data.frame(table(heat3.mouse.id)) ord$occ &lt;- occ[match(ord$mouse.id, occ$heat3.mouse.id), ]$Freq data.wide.sub &lt;- dat[match(colnames(heat3), dat$sample.id), ] col_fun = colorRamp2(c(0, 0.5, 1), c(&quot;white&quot;, &quot;yellow&quot;, &quot;red&quot;)) qpcr &lt;- read.table(&quot;qpcr.csv&quot;, header = T, sep = &quot;;&quot;) qpcr$universal &lt;- NULL rownames(qpcr) &lt;- paste0(qpcr$mouse, &quot;-&quot;, qpcr$day) qpcr &lt;- qpcr[, -c(1:5)] qpcr &lt;- apply(qpcr, 1, function(x) x/sum(x)) qpcr &lt;- qpcr[, which(colnames(qpcr) %in% colnames(heat3))] qpcr &lt;- qpcr[, match(colnames(heat3), colnames(qpcr))] bug &lt;- sapply(strsplit(rownames(heat3), split = &quot;-&quot;, fixed = TRUE), `[`, 1) fixed &lt;- sapply(strsplit(rownames(heat3), split = &quot;-&quot;, fixed = TRUE), `[`, 2) qpcr_1 &lt;- qpcr[1, ] qpcr_2 &lt;- qpcr[2, ] qpcr_3 &lt;- qpcr[3, ] qpcr_4 &lt;- qpcr[4, ] qpcr_5 &lt;- qpcr[5, ] qpcr_6 &lt;- qpcr[6, ] qpcr_7 &lt;- qpcr[7, ] qpcr_8 &lt;- qpcr[8, ] qpcr_9 &lt;- qpcr[9, ] qpcr_10 &lt;- qpcr[10, ] qpcr_11 &lt;- qpcr[11, ] qpcr_12 &lt;- qpcr[12, ] hc = hclust(dist(t(heat3))) Heatmap(matrix(nc = ncol(heat3), nr = 0), column_order = order(ord$mouse.id, ord$day), column_split = heat3.mouse.group, cluster_columns = FALSE, top_annotation = HeatmapAnnotation(day = anno_simple(heat3.day, pch = heat3.phase2), KB1 = anno_lines(log10(qpcr_1), border = T, add_points = TRUE, pt_gp = gpar(col = 1), height = unit(0.7, &quot;cm&quot;), axis = F), YL2 = anno_lines(log10(qpcr_2), border = T, add_points = TRUE, pt_gp = gpar(col = 2), height = unit(0.7, &quot;cm&quot;), axis = F), KB18 = anno_lines(log10(qpcr_3), border = T, add_points = TRUE, pt_gp = gpar(col = 3), height = unit(1, &quot;cm&quot;), axis = F), YL27 = anno_lines(log10(qpcr_4), border = T, add_points = TRUE, pt_gp = gpar(col = 4), height = unit(1, &quot;cm&quot;), axis = F), YL31 = anno_lines(log10(qpcr_5), border = T, add_points = TRUE, pt_gp = gpar(col = 5), height = unit(1, &quot;cm&quot;), axis = F), YL32 = anno_lines(log10(qpcr_6), border = T, add_points = TRUE, pt_gp = gpar(col = 6), height = unit(1, &quot;cm&quot;), axis = F), YL44 = anno_lines(log10(qpcr_7), border = T, add_points = TRUE, pt_gp = gpar(col = 7), height = unit(1, &quot;cm&quot;), axis = F), YL45 = anno_lines(log10(qpcr_8), border = TRUE, add_points = TRUE, pt_gp = gpar(col = 8), height = unit(1, &quot;cm&quot;), axis = F), I46 = anno_lines(log10(qpcr_9), border = TRUE, add_points = TRUE, pt_gp = gpar(col = 9), height = unit(1, &quot;cm&quot;), axis = F), I48 = anno_lines(log10(qpcr_10), border = TRUE, add_points = TRUE, pt_gp = gpar(col = 10), height = unit(1, &quot;cm&quot;), axis = F), I49 = anno_lines(log10(qpcr_11), border = TRUE, add_points = TRUE, pt_gp = gpar(col = 11), height = unit(1, &quot;cm&quot;), axis = F), YL58 = anno_lines(log10(qpcr_12), border = TRUE, add_points = TRUE, pt_gp = gpar(col = 12), height = unit(1, &quot;cm&quot;), axis = F), ra = anno_barplot(t(qpcr), bar_width = 1, gp = gpar(fill = 1:12), height = unit(1.5, &quot;cm&quot;), num = anno_lines(colSums(heat3), smooth = TRUE, border = TRUE)))) "],
["lofreq-threshold.html", "Section 6 Lofreq threshold 6.1 read in vcf 6.2 plot AF comparison", " Section 6 Lofreq threshold 6.1 read in vcf source(&quot;utils.R&quot;) orf_shapes &lt;- c(coding = 15, `non-coding` = 3) vcftodataframe &lt;- function(vcffiles, contig_mapping = contig_mapping, gffdf = gffdf) { require(vcfR) res &lt;- list() for (file in vcffiles) { library(data.table) vcfcontent &lt;- vcfR::read.vcfR(file, verbose = FALSE) vcffix &lt;- as.data.frame(vcfcontent@fix) vcfinfo &lt;- vcfR::INFO2df(vcfcontent) if (nrow(vcffix) &gt; 0) { # there are variants dat &lt;- as.data.frame(cbind(vcffix[, c(1, 2, 4, 5, 6)], vcfinfo[, c(1, 2)])) # transforms e.g. AF of 0.1 to 0.9, 0.9 stays 0.9 and 0.5 stays 0.5 dat$majorAF &lt;- sapply(dat$AF, minorAfToMajorAf) dat$genome &lt;- contig_mapping[match(dat$CHROM, contig_mapping$contig), ]$genome dat$genome_hr &lt;- translateGenomeIdToFullName(tolower(dat$genome)) dat$dp &lt;- as.numeric(as.matrix(vcfinfo$DP)) dat$sample &lt;- tools::file_path_sans_ext(basename(file)) res[[tools::file_path_sans_ext(basename(file))]] &lt;- dat } else { message(&quot;Skipping&quot;) } } df &lt;- as.data.frame(do.call(rbind, res)) # merge list to df return(df) } 6.2 plot AF comparison gfffiles &lt;- Sys.glob(&quot;data/references/gff/*.gff&quot;) gffdf &lt;- NULL for (gfffile in gfffiles) { message(gfffile) gff &lt;- rtracklayer::readGFF(gfffile) # subset since different columns are present on gff files relevant &lt;- data.frame(start = gff$start, end = gff$end, type = as.character(as.matrix(gff$type)), gene = as.character(as.matrix(gff$gene)), product = as.character(as.matrix(gff$product)), chr = as.character(as.matrix(gff$seqid))) relevant$genome &lt;- substr(basename(gfffile), 1, nchar(basename(gfffile)) - 4) gffdf &lt;- rbind(gffdf, relevant) } ## data/references/gff/I46.gff ## data/references/gff/KB1.gff ## data/references/gff/YL58.gff contig_mapping &lt;- read.csv2(&quot;data/contig_mapping_new_ref.csv&quot;, sep = &quot;;&quot;, header = T, stringsAsFactors = F) # this file contains contig names of the 12 OligoMM genomes vcffiles &lt;- Sys.glob(&quot;lofreq_threshold/*.vcf&quot;) vcfsamples &lt;- suppressWarnings(vcftodataframe(vcffiles, contig_mapping, gffdf = gffdf)) p &lt;- ggplot(vcfsamples, aes(AF)) + geom_histogram() p &lt;- p + facet_grid(sample ~ .) p &lt;- p + theme_classic() + xlab(&quot;AF&quot;) + ylab(&quot;occurence&quot;) plotly::ggplotly(p) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. "],
["process-kraken-output.html", "Section 7 process kraken output 7.1 plot", " Section 7 process kraken output #&#39; Read Kraken-style and MetaPhlAn reports #&#39; #&#39; @param myfile Kraken-style or MetaPhlAn report file. #&#39; @param has_header If the kraken report has a header or not. #&#39; @param check_file If TRUE, only the first 5 lines of the file are loaded. #&#39; #&#39; @return report data.frame #&#39; @export #&#39; read_report &lt;- function(myfile, has_header = NULL, check_file = FALSE) { # TODO: Support for gzipped files .. myfile &lt;- file(myfile) file_class &lt;- summary(myfile)$class if # (file_class == &#39;gzfile&#39;) myfile &lt;- gzcon(myfile) first.line &lt;- tryCatch(readLines(myfile, n = 1, warn = FALSE), error = function(e) { warning(&quot;Error reading &quot;, myfile) return() }) isASCII &lt;- function(txt) { if (length(txt) == 0) return(FALSE) raw &lt;- charToRaw(txt) all(raw &lt;= as.raw(127) &amp;&amp; (raw &gt;= as.raw(32) | raw == as.raw(9))) } if (length(first.line) == 0) { message(&quot;Could not read &quot;, myfile, &quot;.&quot;) return(NULL) } tryCatch({ if (nchar(first.line) == 0) { message(&quot;First line of &quot;, myfile, &quot; is empty&quot;) return(NULL) } }, error = function(e) { message(e) return(NULL) }) if (!isTRUE(isASCII(first.line))) { message(myfile, &quot; is not a ASCII file&quot;) return(NULL) } if (is.null(has_header)) { has_header &lt;- grepl(&quot;^[a-zA-Z#%\\&quot;]&quot;, first.line) } is_krakenu_fmt &lt;- grepl(&quot;^.?%\\treads\\ttaxReads\\tkmers&quot;, first.line) is_kaiju_fmt &lt;- grepl(&quot;^ *%\\t *reads&quot;, first.line) nrows &lt;- ifelse(isTRUE(check_file), 5, -1) if (!is_krakenu_fmt &amp;&amp; is_kaiju_fmt) { cont &lt;- readLines(myfile) cont &lt;- cont[!grepl(&quot;^-&quot;, cont)] cont &lt;- sub(&quot;.*\\t *&quot;, &quot;&quot;, cont) cont &lt;- sub(&quot;; ?$&quot;, &quot;&quot;, cont) report &lt;- utils::read.delim(textConnection(cont), stringsAsFactors = FALSE) colnames(report) &lt;- c(&quot;taxonReads&quot;, &quot;taxLineage&quot;) report$cladeReads &lt;- report$taxonReads report$taxLineage &lt;- gsub(&quot;^&quot;, &quot;-_&quot;, report$taxLineage) report$taxLineage &lt;- gsub(&quot;; &quot;, &quot;|-_&quot;, report$taxLineage) report$taxLineage &lt;- gsub(&quot;-_Viruses&quot;, &quot;d_Viruses&quot;, report$taxLineage, fixed = T) report$taxLineage &lt;- gsub(&quot;-_cellular organisms|-_Bacteria&quot;, &quot;-_cellular organisms|d_Bacteria&quot;, report$taxLineage, fixed = T) report$taxLineage &lt;- gsub(&quot;-_cellular organisms|-_Eukaryota&quot;, &quot;-_cellular organisms|d_Eukaryota&quot;, report$taxLineage, fixed = T) report$taxLineage &lt;- gsub(&quot;-_cellular organisms|-_Archaea&quot;, &quot;-_cellular organisms|d_Archaea&quot;, report$taxLineage, fixed = T) report$taxLineage[1:(length(report$taxLineage) - 1)] &lt;- paste0(&quot;-_root|&quot;, report$taxLineage[1:(length(report$taxLineage) - 1)]) report$taxLineage[report$taxLineage == &quot;-_unclassified&quot;] &lt;- &quot;u_unclassified&quot; new_counts &lt;- integer(length = 0) for (j in seq_len(nrow(report))) { count &lt;- report$cladeReads[j] tl &lt;- report$taxLineage[j] tl2 &lt;- sub(&quot;\\\\|[^|]*$&quot;, &quot;&quot;, tl) while (tl2 != tl) { if (tl2 %in% names(new_counts)) { new_counts[tl2] &lt;- new_counts[tl2] + count } else { new_counts[tl2] &lt;- count } tl &lt;- tl2 tl2 &lt;- sub(&quot;\\\\|[^|]*$&quot;, &quot;&quot;, tl) } } report &lt;- rbind(report, data.frame(taxonReads = 0, taxLineage = names(new_counts), cladeReads = as.integer(new_counts))) tl_order &lt;- order(report$taxLineage) tl_order &lt;- c(tl_order[length(tl_order)], tl_order[-length(tl_order)]) report &lt;- report[tl_order, c(&quot;taxLineage&quot;, &quot;taxonReads&quot;, &quot;cladeReads&quot;)] } else if (has_header) { report &lt;- tryCatch({ utils::read.table(myfile, sep = &quot;\\t&quot;, header = T, quote = &quot;&quot;, stringsAsFactors = FALSE, comment.char = &quot;#&quot;, nrows = nrows, check.names = FALSE) }, error = function(x) NULL, warning = function(x) NULL) if (is.null(report)) { return(NULL) } # colnames(report) &lt;- # c(&#39;percentage&#39;,&#39;cladeReads&#39;,&#39;taxonReads&#39;,&#39;taxRank&#39;,&#39;taxID&#39;,&#39;n_unique_kmers&#39;,&#39;n_kmers&#39;,&#39;perc_uniq_kmers&#39;,&#39;name&#39;) ## harmonize column names. TODO: Harmonize them in the scripts! colnames(report)[colnames(report) %in% c(&quot;#%&quot;, &quot;%&quot;, &quot;clade_perc&quot;, &quot;perc&quot;, &quot;percReadsClade&quot;)] &lt;- &quot;percentage&quot; colnames(report)[colnames(report) %in% c(&quot;reads&quot;, &quot;numReadsClade&quot;, &quot;n_reads_clade&quot;, &quot;n.clade&quot;, &quot;n-clade&quot;)] &lt;- &quot;cladeReads&quot; colnames(report)[colnames(report) %in% c(&quot;taxReads&quot;, &quot;numReadsTaxon&quot;, &quot;n_reads_taxo&quot;, &quot;n.stay&quot;, &quot;n-stay&quot;)] &lt;- &quot;taxonReads&quot; colnames(report)[colnames(report) %in% c(&quot;rank&quot;, &quot;tax_taxRank&quot;, &quot;level&quot;)] &lt;- &quot;taxRank&quot; colnames(report)[colnames(report) %in% c(&quot;tax&quot;, &quot;taxonid&quot;)] &lt;- &quot;taxID&quot; colnames(report)[colnames(report) %in% c(&quot;indentedName&quot;, &quot;taxName&quot;)] &lt;- &quot;name&quot; colnames(report)[colnames(report) %in% c(&quot;dup&quot;)] &lt;- &quot;kmerDuplicity&quot; colnames(report)[colnames(report) %in% c(&quot;cov&quot;)] &lt;- &quot;kmerCoverage&quot; } else { report &lt;- tryCatch({ utils::read.table(myfile, sep = &quot;\\t&quot;, header = F, col.names = c(&quot;percentage&quot;, &quot;cladeReads&quot;, &quot;taxonReads&quot;, &quot;taxRank&quot;, &quot;taxID&quot;, &quot;name&quot;), quote = &quot;&quot;, stringsAsFactors = FALSE, nrows = nrows) }, error = function(x) NULL, warning = function(x) NULL) if (is.null(report)) { return(NULL) } } if (ncol(report) &lt; 2) { return(NULL) } if (colnames(report)[2] == &quot;Metaphlan2_Analysis&quot;) { ## Metaphlan report colnames(report) &lt;- c(&quot;taxLineage&quot;, &quot;cladeReads&quot;) report &lt;- report[order(report$taxLineage), ] report$taxLineage &lt;- gsub(&quot;_&quot;, &quot; &quot;, report$taxLineage) report$taxLineage &lt;- gsub(&quot; &quot;, &quot;_&quot;, report$taxLineage) report$taxLineage &lt;- paste0(&quot;-_root|&quot;, report$taxLineage) report &lt;- rbind(data.frame(taxLineage = c(&quot;u_unclassified&quot;, &quot;-_root&quot;), cladeReads = c(0, 100), stringsAsFactors = F), report) } if (all(c(&quot;name&quot;, &quot;taxRank&quot;) %in% colnames(report)) &amp;&amp; !&quot;taxLineage&quot; %in% colnames(report)) { ## Kraken report report$depth &lt;- nchar(gsub(&quot;\\\\S.*&quot;, &quot;&quot;, report$name))/2 if (!all(report$depth == floor(report$depth))) { warning(&quot;Depth doesn&#39;t work out!&quot;) return(NULL) } report$name &lt;- gsub(&quot;^ *&quot;, &quot;&quot;, report$name) ## &#39;fix&#39; taxRank table(report$taxRank) allowed_taxRanks &lt;- c(&quot;U&quot;, &quot;S&quot;, &quot;G&quot;, &quot;F&quot;, &quot;C&quot;, &quot;D&quot;, &quot;O&quot;, &quot;K&quot;, &quot;P&quot;) report$taxRank[report$taxRank == &quot;class&quot;] &lt;- &quot;C&quot; report$taxRank[report$taxRank == &quot;family&quot;] &lt;- &quot;F&quot; report$taxRank[report$taxRank == &quot;genus&quot;] &lt;- &quot;G&quot; report$taxRank[report$taxRank == &quot;superkingdom&quot;] &lt;- &quot;D&quot; report$taxRank[report$taxRank == &quot;kingdom&quot;] &lt;- &quot;K&quot; report$taxRank[report$taxRank == &quot;order&quot;] &lt;- &quot;O&quot; report$taxRank[report$taxRank == &quot;phylum&quot;] &lt;- &quot;P&quot; report$taxRank[report$taxRank == &quot;species&quot;] &lt;- &quot;S&quot; report$taxRank[report$name == &quot;unclassified&quot;] &lt;- &quot;U&quot; report$taxRank[!report$taxRank %in% allowed_taxRanks] &lt;- &quot;-&quot; report$name &lt;- paste(tolower(report$taxRank), report$name, sep = &quot;_&quot;) rownames(report) &lt;- NULL ## make taxLineage path report$taxLineage &lt;- report$name n &lt;- nrow(report) depths &lt;- report$depth taxLineages &lt;- report$name taxLineages_p &lt;- as.list(seq_along(report$name)) depth_row_tmp &lt;- c(1:25) for (current_row in seq(from = 1, to = nrow(report))) { dcr &lt;- depths[current_row] depth_row_tmp[dcr + 1] &lt;- current_row if (dcr &gt;= 1) { prev_pos &lt;- depth_row_tmp[[dcr]] taxLineages_p[[current_row]] &lt;- c(taxLineages_p[[prev_pos]], current_row) } } report$taxLineage &lt;- sapply(taxLineages_p, function(x) paste0(taxLineages[x], collapse = &quot;|&quot;)) # report$taxLineage &lt;- taxLineages } else if (&quot;taxLineage&quot; %in% colnames(report)) { taxLineages &lt;- strsplit(report$taxLineage, &quot;|&quot;, fixed = TRUE) if (!&quot;name&quot; %in% colnames(report)) report$name &lt;- sapply(taxLineages, function(x) x[length(x)]) if (!&quot;depth&quot; %in% colnames(report)) { report$depth &lt;- sapply(taxLineages, length) - 1 } if (!&quot;taxRank&quot; %in% colnames(report)) report$taxRank &lt;- toupper(substr(report$name, 0, 1)) } if (!all(c(&quot;name&quot;, &quot;taxRank&quot;) %in% colnames(report)) || nrow(report) &lt; 2 || !((report[1, &quot;name&quot;] == &quot;u_unclassified&quot; &amp;&amp; report[2, &quot;name&quot;] == &quot;-_root&quot;) || report[1, &quot;name&quot;] == &quot;-_root&quot;)) { message(paste(&quot;Warning: File&quot;, myfile, &quot;does not have the required format&quot;)) print(utils::head(report)) return(NULL) } if (!&quot;taxonReads&quot; %in% colnames(report)) { parent &lt;- sub(&quot;^\\\\(.*\\\\)\\\\|.*$&quot;, &quot;\\\\1&quot;, report$taxLineage) taxLineages &lt;- strsplit(report$taxLineage, &quot;|&quot;, fixed = TRUE) ## fix taxonReads report$taxonReads &lt;- report$cladeReads - sapply(report$name, function(x) sum(report$cladeReads[parent == x])) # report$taxonReads[sapply(report$taxonReads, function(x) isTRUE(all.equal(x, 0)))] &lt;- 0 report$taxonReads[report$taxonReads &lt;= 1e-05] &lt;- 0 # fix for rounding in percentages by MetaPhlAn } report$percentage &lt;- signif(report$cladeReads/sum(report$taxonReads), 6) * 100 if (&quot;n_unique_kmers&quot; %in% colnames(report)) report$kmerpercentage &lt;- round(report$n_unique_kmers/sum(report$n_unique_kmers, na.rm = T), 6) * 100 # report$taxRankperc &lt;- 100/taxRank(report$cladeReads) # report$depth &lt;- NULL if (&quot;taxID&quot; %in% colnames(report)) { std_colnames &lt;- c(&quot;percentage&quot;, &quot;cladeReads&quot;, &quot;taxonReads&quot;, &quot;taxRank&quot;, &quot;taxID&quot;, &quot;name&quot;) } else { std_colnames &lt;- c(&quot;percentage&quot;, &quot;cladeReads&quot;, &quot;taxonReads&quot;, &quot;taxRank&quot;, &quot;name&quot;) } stopifnot(all(std_colnames %in% colnames(report))) report[, c(std_colnames, setdiff(colnames(report), std_colnames))] } #&#39; Read kraken or centrifuge-style report #&#39; #&#39; @param myfile kraken report file #&#39; @param collapse should the results be collapsed to only those taxRanks specified in keep_taxRanks? #&#39; @param keep_taxRanks taxRanks to keep when collapse is TRUE #&#39; @param min.depth minimum depth #&#39; @param filter_taxon filter certain taxon names #&#39; @param has_header if the kraken report has a header or not #&#39; @param add_taxRank_columns if TRUE, for each taxRank columns are added #&#39; #&#39; @return report data.frame #&#39; @export #&#39; read_report2 &lt;- function(myfile, collapse = TRUE, keep_taxRanks = c(&quot;D&quot;, &quot;K&quot;, &quot;P&quot;, &quot;C&quot;, &quot;O&quot;, &quot;F&quot;, &quot;G&quot;, &quot;S&quot;), min.depth = 0, filter_taxon = NULL, has_header = NULL, add_taxRank_columns = FALSE) { first.line &lt;- readLines(myfile, n = 1) isASCII &lt;- function(txt) all(charToRaw(txt) &lt;= as.raw(127)) if (!isASCII(first.line)) { message(myfile, &quot; is no valid report - not all characters are ASCII&quot;) return(NULL) } if (is.null(has_header)) { has_header &lt;- grepl(&quot;^[a-zA-Z]&quot;, first.line) } if (has_header) { report &lt;- utils::read.table(myfile, sep = &quot;\\t&quot;, header = T, quote = &quot;&quot;, stringsAsFactors = FALSE, comment.char = &quot;#&quot;) # colnames(report) &lt;- # c(&#39;percentage&#39;,&#39;cladeReads&#39;,&#39;taxonReads&#39;,&#39;taxRank&#39;,&#39;taxID&#39;,&#39;n_unique_kmers&#39;,&#39;n_kmers&#39;,&#39;perc_uniq_kmers&#39;,&#39;name&#39;) ## harmonize column names. TODO: Harmonize them in the scripts! colnames(report)[colnames(report) == &quot;clade_perc&quot;] &lt;- &quot;percentage&quot; colnames(report)[colnames(report) == &quot;perc&quot;] &lt;- &quot;percentage&quot; colnames(report)[colnames(report) == &quot;n_reads_clade&quot;] &lt;- &quot;cladeReads&quot; colnames(report)[colnames(report) == &quot;n.clade&quot;] &lt;- &quot;cladeReads&quot; colnames(report)[colnames(report) == &quot;n_reads_taxo&quot;] &lt;- &quot;taxonReads&quot; colnames(report)[colnames(report) == &quot;n.stay&quot;] &lt;- &quot;taxonReads&quot; colnames(report)[colnames(report) == &quot;rank&quot;] &lt;- &quot;taxRank&quot; colnames(report)[colnames(report) == &quot;tax_rank&quot;] &lt;- &quot;taxRank&quot; colnames(report)[colnames(report) == &quot;taxonid&quot;] &lt;- &quot;taxID&quot; colnames(report)[colnames(report) == &quot;tax&quot;] &lt;- &quot;taxID&quot; } else { report &lt;- utils::read.table(myfile, sep = &quot;\\t&quot;, header = F, col.names = c(&quot;percentage&quot;, &quot;cladeReads&quot;, &quot;taxonReads&quot;, &quot;taxRank&quot;, &quot;taxID&quot;, &quot;name&quot;), quote = &quot;&quot;, stringsAsFactors = FALSE, comment.char = &quot;#&quot;) } report$depth &lt;- nchar(gsub(&quot;\\\\S.*&quot;, &quot;&quot;, report$name))/2 report$name &lt;- gsub(&quot;^ *&quot;, &quot;&quot;, report$name) report$name &lt;- paste(tolower(report$taxRank), report$name, sep = &quot;_&quot;) ## Only stop at certain taxRanks filter taxon and further up the tree if &#39;filter_taxon&#39; is defined kraken.tree &lt;- build_kraken_tree(report) report &lt;- collapse.taxRanks(kraken.tree, keep_taxRanks = keep_taxRanks, filter_taxon = filter_taxon) ## Add a metaphlan-style taxon string if (add_taxRank_columns) { report[, keep_taxRanks] &lt;- NA } report$taxLineage = report$name rows_to_consider &lt;- rep(FALSE, nrow(report)) for (i in seq_len(nrow(report))) { ## depth &gt; 2 correspond to taxRanks below &#39;D&#39; if (i &gt; 1 &amp;&amp; report[i, &quot;depth&quot;] &gt; min.depth) { ## find the maximal index of a row below the current depth idx &lt;- report$depth &lt; report[i, &quot;depth&quot;] &amp; rows_to_consider if (!any(idx)) { (next)() } current.taxRank &lt;- report[i, &quot;taxRank&quot;] my_row &lt;- max(which(idx)) report[i, &quot;taxLineage&quot;] &lt;- paste(report[my_row, &quot;taxLineage&quot;], report[i, &quot;taxLineage&quot;], sep = &quot;|&quot;) if (add_taxRank_columns) { if (report[my_row, &quot;taxRank&quot;] %in% keep_taxRanks) { taxRanks.cp &lt;- keep_taxRanks[seq(from = 1, to = which(keep_taxRanks == report[my_row, &quot;taxRank&quot;]))] report[i, taxRanks.cp] &lt;- report[my_row, taxRanks.cp] } report[i, report[i, &quot;taxRank&quot;]] &lt;- report[i, &quot;name&quot;] } } rows_to_consider[i] &lt;- TRUE } report &lt;- report[report$depth &gt;= min.depth, ] report$percentage &lt;- round(report$cladeReads/sum(report$taxonReads), 6) * 100 for (column in c(&quot;taxonReads&quot;, &quot;cladeReads&quot;)) if (all(floor(report[[column]]) == report[[column]])) report[[column]] &lt;- as.integer(report[[column]]) if (&quot;n_unique_kmers&quot; %in% colnames(report)) report$kmerpercentage &lt;- round(report$n_unique_kmers/sum(report$n_unique_kmers, na.rm = T), 6) * 100 # report$taxRankperc &lt;- 100/taxRank(report$cladeReads) rownames(report) &lt;- NULL report } #&#39; Filter lines from a kraken report result based on the taxonomy name #&#39; #&#39; It updates the read_stay counts, and removes any children below the #&#39; entry, and any parent entries that have no &#39;cladeReads&#39; that stay #&#39; #&#39; @param report Report \\code{data.frame}. #&#39; @param filter_taxon Name of entry to remove. #&#39; @param rm_clade If \\code{TRUE}, remove all cladeReads at and below clade, otherwise just set the number of cladeReads that stay at taxon to zero. #&#39; @param do_message If \\code{TRUE}, report how many rows and cladeReads were deleted. #&#39; #&#39; @return filtered report #&#39; @export filter_taxon &lt;- function(report, filter_taxon, rm_clade = TRUE, do_message = FALSE) { taxon_depth &lt;- NULL taxonReads &lt;- 0 pos.taxons &lt;- which(sub(&quot;._&quot;, &quot;&quot;, report$name) %in% filter_taxon) # pos.taxon &lt;- which(report$name := filter_taxon) if (length(pos.taxons) == 0) { return(report) } row_seq &lt;- seq_len(nrow(report)) rows_to_delete &lt;- rep(FALSE, nrow(report)) taxon_depths &lt;- report[pos.taxons, &quot;depth&quot;] if (isTRUE(rm_clade)) { taxonReads &lt;- report[pos.taxons, &quot;cladeReads&quot;] } else { taxonReads &lt;- report[pos.taxons, &quot;taxonReads&quot;] report[pos.taxons, &quot;taxonReads&quot;] &lt;- 0 } for (i in seq_along(pos.taxons)) { pos.taxon &lt;- pos.taxons[i] if (pos.taxon == 1) { rows_to_delete[1] &lt;- TRUE next } taxon_depth &lt;- taxon_depths[i] taxonReads &lt;- taxonReads[i] if (rm_clade) { tosum_below &lt;- row_seq &gt;= pos.taxon &amp; report$depth &lt;= taxon_depth taxons_below &lt;- cumsum(tosum_below) == 1 rows_to_delete[taxons_below] &lt;- TRUE } rows_to_update &lt;- c(pos.taxon) taxons_above &lt;- seq_len(nrow(report)) &lt; pos.taxon &amp; report$depth == taxon_depth any_stays &lt;- FALSE prev_taxon_depth &lt;- taxon_depth taxons_above &lt;- c() for (i in seq(from = (pos.taxon - 1), to = 1)) { curr_taxon_depth &lt;- report[i, &quot;depth&quot;] if (curr_taxon_depth &lt; prev_taxon_depth) { if (!any_stays) { if (report[i, &quot;cladeReads&quot;] == taxonReads) { rows_to_delete[i] &lt;- TRUE if (do_message) message(&quot;Deleting &quot;, report[i, &quot;name&quot;]) } else { any_stays &lt;- TRUE } } if (!rows_to_delete[i]) { rows_to_update &lt;- c(rows_to_update, i) if (do_message) message(&quot;Updating &quot;, report[i, &quot;name&quot;]) } prev_taxon_depth &lt;- curr_taxon_depth } else { any_stays &lt;- TRUE } } report[rows_to_update, &quot;cladeReads&quot;] &lt;- report[rows_to_update, &quot;cladeReads&quot;] - taxonReads } # if (rm_clade) report[!rows_to_delete, ] # else report } taxRanks = c(&quot;G&quot;) reports &lt;- list.files(&quot;kraken/reports&quot;, full.names = T) res &lt;- list() for (report in reports) { dat &lt;- read_report(report) stopifnot(&quot;taxRank&quot; %in% colnames(dat)) if (!any(taxRanks %in% dat$taxRank)) { warning(&quot;report does not contain any of the taxRanks - skipping it&quot;) return() } dat &lt;- subset(dat, taxRank %in% taxRanks) basename &lt;- sub(pattern = &quot;(.*)\\\\..*$&quot;, replacement = &quot;\\\\1&quot;, basename(report)) basename2 &lt;- sub(pattern = &quot;(.*)\\\\..*$&quot;, replacement = &quot;\\\\1&quot;, basename) res[[basename2]] &lt;- data.frame(sample = basename2, ra = dat$percentage, name = dat$name, reads = dat$taxonReads) } df &lt;- as.data.frame(do.call(rbind, res)) # set everything lower than 1% to other df$name &lt;- as.character(as.matrix(df$name)) df[which(df$ra &lt; 0.1), ]$name &lt;- &quot;other&quot; 7.1 plot require(ggplot2) library(RColorBrewer) mycolors &lt;- colorRampPalette(brewer.pal(8, &quot;Dark2&quot;))(length(unique(df$name))) p &lt;- ggplot(df, aes(x = sample, y = ra, fill = name)) p &lt;- p + geom_bar(stat = &quot;identity&quot;) + theme_minimal() + scale_fill_manual(values = mycolors) p &lt;- p + theme(axis.text.x = element_text(angle = 90, hjust = 1)) plotly::ggplotly(p) "]
]
