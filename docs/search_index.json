[
["process-kraken-output.html", "Section 6 process kraken output 6.1 plot", " Section 6 process kraken output #&#39; Read Kraken-style and MetaPhlAn reports #&#39; #&#39; @param myfile Kraken-style or MetaPhlAn report file. #&#39; @param has_header If the kraken report has a header or not. #&#39; @param check_file If TRUE, only the first 5 lines of the file are loaded. #&#39; #&#39; @return report data.frame #&#39; @export #&#39; read_report &lt;- function(myfile, has_header=NULL, check_file = FALSE) { # TODO: Support for gzipped files .. #myfile &lt;- file(myfile) #file_class &lt;- summary(myfile)$class #if (file_class == &quot;gzfile&quot;) # myfile &lt;- gzcon(myfile) first.line &lt;- tryCatch( readLines(myfile,n=1, warn=FALSE), error = function(e) { warning(&quot;Error reading &quot;,myfile); return() }) isASCII &lt;- function(txt) { if (length(txt) == 0) return(FALSE) raw &lt;- charToRaw(txt) all(raw &lt;= as.raw(127) &amp;&amp; (raw &gt;= as.raw(32) | raw == as.raw(9))) } if (length(first.line) == 0) { message(&quot;Could not read &quot;, myfile, &quot;.&quot;) return(NULL) } tryCatch({ if (nchar(first.line) == 0) { message(&quot;First line of &quot;, myfile, &quot; is empty&quot;) return(NULL) } }, error = function(e) { message(e) return(NULL) }) if (!isTRUE(isASCII(first.line))) { message(myfile,&quot; is not a ASCII file&quot;) return(NULL) } if (is.null(has_header)) { has_header &lt;- grepl(&quot;^[a-zA-Z#%\\&quot;]&quot;,first.line) } is_krakenu_fmt &lt;- grepl(&quot;^.?%\\treads\\ttaxReads\\tkmers&quot;, first.line) is_kaiju_fmt &lt;- grepl(&quot;^ *%\\t *reads&quot;, first.line) nrows &lt;- ifelse(isTRUE(check_file), 5, -1) if (!is_krakenu_fmt &amp;&amp; is_kaiju_fmt) { cont &lt;- readLines(myfile) cont &lt;- cont[!grepl(&quot;^-&quot;, cont)] cont &lt;- sub(&quot;.*\\t *&quot;,&quot;&quot;, cont) cont &lt;- sub(&quot;; ?$&quot;,&quot;&quot;, cont) report &lt;- utils::read.delim(textConnection(cont), stringsAsFactors = FALSE) colnames(report) &lt;- c(&quot;taxonReads&quot;, &quot;taxLineage&quot;) report$cladeReads &lt;- report$taxonReads report$taxLineage &lt;- gsub(&quot;^&quot;,&quot;-_&quot;,report$taxLineage) report$taxLineage &lt;- gsub(&quot;; &quot;,&quot;|-_&quot;,report$taxLineage) report$taxLineage &lt;- gsub(&quot;-_Viruses&quot;, &quot;d_Viruses&quot;, report$taxLineage, fixed=T) report$taxLineage &lt;- gsub(&quot;-_cellular organisms|-_Bacteria&quot;, &quot;-_cellular organisms|d_Bacteria&quot;, report$taxLineage, fixed=T) report$taxLineage &lt;- gsub(&quot;-_cellular organisms|-_Eukaryota&quot;, &quot;-_cellular organisms|d_Eukaryota&quot;, report$taxLineage, fixed=T) report$taxLineage &lt;- gsub(&quot;-_cellular organisms|-_Archaea&quot;, &quot;-_cellular organisms|d_Archaea&quot;, report$taxLineage, fixed=T) report$taxLineage[1:(length(report$taxLineage)-1)] &lt;- paste0(&quot;-_root|&quot;, report$taxLineage[1:(length(report$taxLineage)-1)]) report$taxLineage[report$taxLineage==&quot;-_unclassified&quot;] &lt;- &quot;u_unclassified&quot; new_counts &lt;- integer(length = 0) for (j in seq_len(nrow(report))) { count &lt;- report$cladeReads[j] tl &lt;- report$taxLineage[j] tl2 &lt;- sub(&quot;\\\\|[^|]*$&quot;,&quot;&quot;, tl) while (tl2 != tl) { if (tl2 %in% names(new_counts)) { new_counts[tl2] &lt;- new_counts[tl2] + count } else { new_counts[tl2] &lt;- count } tl &lt;- tl2 tl2 &lt;- sub(&quot;\\\\|[^|]*$&quot;,&quot;&quot;, tl) } } report &lt;- rbind(report, data.frame(taxonReads=0,taxLineage=names(new_counts),cladeReads=as.integer(new_counts))) tl_order &lt;- order(report$taxLineage) tl_order &lt;- c(tl_order[length(tl_order)],tl_order[-length(tl_order)]) report &lt;- report[tl_order, c(&quot;taxLineage&quot;, &quot;taxonReads&quot;, &quot;cladeReads&quot;)] } else if (has_header) { report &lt;- tryCatch({ utils::read.table(myfile,sep=&quot;\\t&quot;,header = T, quote = &quot;&quot;,stringsAsFactors=FALSE, comment.char = &quot;#&quot;, nrows = nrows, check.names=FALSE) }, error = function(x) NULL, warning = function(x) NULL) if (is.null(report)) { return(NULL); } #colnames(report) &lt;- c(&quot;percentage&quot;,&quot;cladeReads&quot;,&quot;taxonReads&quot;,&quot;taxRank&quot;,&quot;taxID&quot;,&quot;n_unique_kmers&quot;,&quot;n_kmers&quot;,&quot;perc_uniq_kmers&quot;,&quot;name&quot;) ## harmonize column names. TODO: Harmonize them in the scripts! colnames(report)[colnames(report) %in% c(&quot;#%&quot;,&quot;%&quot;,&quot;clade_perc&quot;,&quot;perc&quot;,&quot;percReadsClade&quot;)] &lt;- &quot;percentage&quot; colnames(report)[colnames(report) %in% c(&quot;reads&quot;,&quot;numReadsClade&quot;,&quot;n_reads_clade&quot;,&quot;n.clade&quot;,&quot;n-clade&quot;)] &lt;- &quot;cladeReads&quot; colnames(report)[colnames(report) %in% c(&quot;taxReads&quot;,&quot;numReadsTaxon&quot;,&quot;n_reads_taxo&quot;,&quot;n.stay&quot;,&quot;n-stay&quot;)] &lt;- &quot;taxonReads&quot; colnames(report)[colnames(report) %in% c(&quot;rank&quot;,&quot;tax_taxRank&quot;,&quot;level&quot;)] &lt;- &quot;taxRank&quot; colnames(report)[colnames(report) %in% c(&quot;tax&quot;,&quot;taxonid&quot;)] &lt;- &quot;taxID&quot; colnames(report)[colnames(report) %in% c(&quot;indentedName&quot;,&quot;taxName&quot;)] &lt;- &quot;name&quot; colnames(report)[colnames(report) %in% c(&quot;dup&quot;)] &lt;- &quot;kmerDuplicity&quot; colnames(report)[colnames(report) %in% c(&quot;cov&quot;)] &lt;- &quot;kmerCoverage&quot; } else { report &lt;- tryCatch({ utils::read.table(myfile,sep=&quot;\\t&quot;,header = F, col.names = c(&quot;percentage&quot;,&quot;cladeReads&quot;,&quot;taxonReads&quot;,&quot;taxRank&quot;,&quot;taxID&quot;,&quot;name&quot;), quote = &quot;&quot;,stringsAsFactors=FALSE, nrows = nrows) }, error=function(x) NULL, warning=function(x) NULL) if (is.null(report)) { return(NULL); } } if (ncol(report) &lt; 2) { return(NULL) } if (colnames(report)[2] == &quot;Metaphlan2_Analysis&quot;) { ## Metaphlan report colnames(report) &lt;- c(&quot;taxLineage&quot;, &quot;cladeReads&quot;) report &lt;- report[order(report$taxLineage), ] report$taxLineage &lt;- gsub(&quot;_&quot;,&quot; &quot;,report$taxLineage) report$taxLineage &lt;- gsub(&quot; &quot;,&quot;_&quot;,report$taxLineage) report$taxLineage &lt;- paste0(&quot;-_root|&quot;, report$taxLineage) report &lt;- rbind( data.frame(taxLineage=c(&quot;u_unclassified&quot;,&quot;-_root&quot;),&quot;cladeReads&quot;=c(0,100), stringsAsFactors = F), report) } if (all(c(&quot;name&quot;,&quot;taxRank&quot;) %in% colnames(report)) &amp;&amp; !&quot;taxLineage&quot; %in% colnames(report)) { ## Kraken report report$depth &lt;- nchar(gsub(&quot;\\\\S.*&quot;,&quot;&quot;,report$name))/2 if (!all(report$depth == floor(report$depth))) { warning(&quot;Depth doesn&#39;t work out!&quot;) return(NULL) } report$name &lt;- gsub(&quot;^ *&quot;,&quot;&quot;,report$name) ## &#39;fix&#39; taxRank table(report$taxRank) allowed_taxRanks &lt;- c(&quot;U&quot;, &quot;S&quot;, &quot;G&quot;, &quot;F&quot;, &quot;C&quot;, &quot;D&quot;, &quot;O&quot;, &quot;K&quot;, &quot;P&quot;) report$taxRank[report$taxRank==&quot;class&quot;] &lt;- &quot;C&quot; report$taxRank[report$taxRank==&quot;family&quot;] &lt;- &quot;F&quot; report$taxRank[report$taxRank==&quot;genus&quot;] &lt;- &quot;G&quot; report$taxRank[report$taxRank==&quot;superkingdom&quot;] &lt;- &quot;D&quot; report$taxRank[report$taxRank==&quot;kingdom&quot;] &lt;- &quot;K&quot; report$taxRank[report$taxRank==&quot;order&quot;] &lt;- &quot;O&quot; report$taxRank[report$taxRank==&quot;phylum&quot;] &lt;- &quot;P&quot; report$taxRank[report$taxRank==&quot;species&quot;] &lt;- &quot;S&quot; report$taxRank[report$name==&quot;unclassified&quot;] &lt;- &quot;U&quot; report$taxRank[!report$taxRank %in% allowed_taxRanks] &lt;- &quot;-&quot; report$name &lt;- paste(tolower(report$taxRank),report$name,sep=&quot;_&quot;) rownames(report) &lt;- NULL ## make taxLineage path report$taxLineage &lt;- report$name n &lt;- nrow(report) depths &lt;- report$depth taxLineages &lt;- report$name taxLineages_p &lt;- as.list(seq_along(report$name)) depth_row_tmp &lt;- c(1:25) for (current_row in seq(from=1, to=nrow(report))) { dcr &lt;- depths[current_row] depth_row_tmp[dcr+1] &lt;- current_row if (dcr &gt;= 1) { prev_pos &lt;- depth_row_tmp[[dcr]] taxLineages_p[[current_row]] &lt;- c(taxLineages_p[[prev_pos]], current_row) } } report$taxLineage &lt;- sapply(taxLineages_p, function(x) paste0(taxLineages[x], collapse=&quot;|&quot;)) #report$taxLineage &lt;- taxLineages } else if (&quot;taxLineage&quot; %in% colnames(report)) { taxLineages &lt;- strsplit(report$taxLineage, &quot;|&quot;, fixed=TRUE) if (!&quot;name&quot; %in% colnames(report)) report$name &lt;- sapply(taxLineages, function(x) x[length(x)]) if (!&quot;depth&quot; %in% colnames(report)) { report$depth &lt;- sapply(taxLineages, length) - 1 } if (!&quot;taxRank&quot; %in% colnames(report)) report$taxRank &lt;- toupper(substr(report$name, 0, 1)) } if (!all(c(&quot;name&quot;,&quot;taxRank&quot;) %in% colnames(report)) || nrow(report) &lt; 2 || !((report[1,&quot;name&quot;] == &quot;u_unclassified&quot; &amp;&amp; report[2,&quot;name&quot;] == &quot;-_root&quot;) || report[1,&quot;name&quot;] == &quot;-_root&quot;)) { message(paste(&quot;Warning: File&quot;,myfile,&quot;does not have the required format&quot;)) print(utils::head(report)) return(NULL) } if (!&quot;taxonReads&quot; %in% colnames(report)) { parent &lt;- sub(&quot;^\\\\(.*\\\\)\\\\|.*$&quot;, &quot;\\\\1&quot;, report$taxLineage) taxLineages &lt;- strsplit(report$taxLineage, &quot;|&quot;, fixed=TRUE) ## fix taxonReads report$taxonReads &lt;- report$cladeReads - sapply(report$name, function(x) sum(report$cladeReads[parent == x])) #report$taxonReads[sapply(report$taxonReads, function(x) isTRUE(all.equal(x, 0)))] &lt;- 0 report$taxonReads[report$taxonReads &lt;= 0.00001] &lt;- 0 # fix for rounding in percentages by MetaPhlAn } report$percentage &lt;- signif(report$cladeReads/sum(report$taxonReads),6) * 100 if (&#39;n_unique_kmers&#39; %in% colnames(report)) report$kmerpercentage &lt;- round(report$n_unique_kmers/sum(report$n_unique_kmers,na.rm=T),6) * 100 #report$taxRankperc &lt;- 100/taxRank(report$cladeReads) #report$depth &lt;- NULL if (&quot;taxID&quot; %in% colnames(report)) { std_colnames &lt;- c(&quot;percentage&quot;,&quot;cladeReads&quot;,&quot;taxonReads&quot;,&quot;taxRank&quot;, &quot;taxID&quot;,&quot;name&quot;) } else { std_colnames &lt;- c(&quot;percentage&quot;,&quot;cladeReads&quot;,&quot;taxonReads&quot;,&quot;taxRank&quot;,&quot;name&quot;) } stopifnot(all(std_colnames %in% colnames(report))) report[, c(std_colnames, setdiff(colnames(report), std_colnames))] } #&#39; Read kraken or centrifuge-style report #&#39; #&#39; @param myfile kraken report file #&#39; @param collapse should the results be collapsed to only those taxRanks specified in keep_taxRanks? #&#39; @param keep_taxRanks taxRanks to keep when collapse is TRUE #&#39; @param min.depth minimum depth #&#39; @param filter_taxon filter certain taxon names #&#39; @param has_header if the kraken report has a header or not #&#39; @param add_taxRank_columns if TRUE, for each taxRank columns are added #&#39; #&#39; @return report data.frame #&#39; @export #&#39; read_report2 &lt;- function(myfile,collapse=TRUE,keep_taxRanks=c(&quot;D&quot;,&quot;K&quot;,&quot;P&quot;,&quot;C&quot;,&quot;O&quot;,&quot;F&quot;,&quot;G&quot;,&quot;S&quot;),min.depth=0,filter_taxon=NULL, has_header=NULL,add_taxRank_columns=FALSE) { first.line &lt;- readLines(myfile,n=1) isASCII &lt;- function(txt) all(charToRaw(txt) &lt;= as.raw(127)) if (!isASCII(first.line)) { message(myfile,&quot; is no valid report - not all characters are ASCII&quot;) return(NULL) } if (is.null(has_header)) { has_header &lt;- grepl(&quot;^[a-zA-Z]&quot;,first.line) } if (has_header) { report &lt;- utils::read.table(myfile,sep=&quot;\\t&quot;,header = T, quote = &quot;&quot;,stringsAsFactors=FALSE, comment.char=&quot;#&quot;) #colnames(report) &lt;- c(&quot;percentage&quot;,&quot;cladeReads&quot;,&quot;taxonReads&quot;,&quot;taxRank&quot;,&quot;taxID&quot;,&quot;n_unique_kmers&quot;,&quot;n_kmers&quot;,&quot;perc_uniq_kmers&quot;,&quot;name&quot;) ## harmonize column names. TODO: Harmonize them in the scripts! colnames(report)[colnames(report)==&quot;clade_perc&quot;] &lt;- &quot;percentage&quot; colnames(report)[colnames(report)==&quot;perc&quot;] &lt;- &quot;percentage&quot; colnames(report)[colnames(report)==&quot;n_reads_clade&quot;] &lt;- &quot;cladeReads&quot; colnames(report)[colnames(report)==&quot;n.clade&quot;] &lt;- &quot;cladeReads&quot; colnames(report)[colnames(report)==&quot;n_reads_taxo&quot;] &lt;- &quot;taxonReads&quot; colnames(report)[colnames(report)==&quot;n.stay&quot;] &lt;- &quot;taxonReads&quot; colnames(report)[colnames(report)==&quot;rank&quot;] &lt;- &quot;taxRank&quot; colnames(report)[colnames(report)==&quot;tax_rank&quot;] &lt;- &quot;taxRank&quot; colnames(report)[colnames(report)==&quot;taxonid&quot;] &lt;- &quot;taxID&quot; colnames(report)[colnames(report)==&quot;tax&quot;] &lt;- &quot;taxID&quot; } else { report &lt;- utils::read.table(myfile,sep=&quot;\\t&quot;,header = F, col.names = c(&quot;percentage&quot;,&quot;cladeReads&quot;,&quot;taxonReads&quot;,&quot;taxRank&quot;,&quot;taxID&quot;,&quot;name&quot;), quote = &quot;&quot;,stringsAsFactors=FALSE, comment.char=&quot;#&quot;) } report$depth &lt;- nchar(gsub(&quot;\\\\S.*&quot;,&quot;&quot;,report$name))/2 report$name &lt;- gsub(&quot;^ *&quot;,&quot;&quot;,report$name) report$name &lt;- paste(tolower(report$taxRank),report$name,sep=&quot;_&quot;) ## Only stop at certain taxRanks ## filter taxon and further up the tree if &#39;filter_taxon&#39; is defined kraken.tree &lt;- build_kraken_tree(report) report &lt;- collapse.taxRanks(kraken.tree,keep_taxRanks=keep_taxRanks,filter_taxon=filter_taxon) ## Add a metaphlan-style taxon string if (add_taxRank_columns) { report[,keep_taxRanks] &lt;- NA } report$taxLineage = report$name rows_to_consider &lt;- rep(FALSE,nrow(report)) for (i in seq_len(nrow(report))) { ## depth &gt; 2 correspond to taxRanks below &#39;D&#39; if (i &gt; 1 &amp;&amp; report[i,&quot;depth&quot;] &gt; min.depth) { ## find the maximal index of a row below the current depth idx &lt;- report$depth &lt; report[i,&quot;depth&quot;] &amp; rows_to_consider if (!any(idx)) { next() } current.taxRank &lt;- report[i,&#39;taxRank&#39;] my_row &lt;- max(which(idx)) report[i,&#39;taxLineage&#39;] &lt;- paste(report[my_row,&#39;taxLineage&#39;],report[i,&#39;taxLineage&#39;],sep=&quot;|&quot;) if (add_taxRank_columns) { if (report[my_row,&#39;taxRank&#39;] %in% keep_taxRanks) { taxRanks.cp &lt;- keep_taxRanks[seq(from=1,to=which(keep_taxRanks == report[my_row,&#39;taxRank&#39;]))] report[i,taxRanks.cp] &lt;- report[my_row,taxRanks.cp] } report[i,report[i,&#39;taxRank&#39;]] &lt;- report[i,&#39;name&#39;] } } rows_to_consider[i] &lt;- TRUE } report &lt;- report[report$depth &gt;= min.depth,] report$percentage &lt;- round(report$cladeReads/sum(report$taxonReads),6) * 100 for (column in c(&quot;taxonReads&quot;, &quot;cladeReads&quot;)) if (all(floor(report[[column]]) == report[[column]])) report[[column]] &lt;- as.integer(report[[column]]) if (&#39;n_unique_kmers&#39; %in% colnames(report)) report$kmerpercentage &lt;- round(report$n_unique_kmers/sum(report$n_unique_kmers,na.rm=T),6) * 100 #report$taxRankperc &lt;- 100/taxRank(report$cladeReads) rownames(report) &lt;- NULL report } #&#39; Filter lines from a kraken report result based on the taxonomy name #&#39; #&#39; It updates the read_stay counts, and removes any children below the #&#39; entry, and any parent entries that have no &quot;cladeReads&quot; that stay #&#39; #&#39; @param report Report \\code{data.frame}. #&#39; @param filter_taxon Name of entry to remove. #&#39; @param rm_clade If \\code{TRUE}, remove all cladeReads at and below clade, otherwise just set the number of cladeReads that stay at taxon to zero. #&#39; @param do_message If \\code{TRUE}, report how many rows and cladeReads were deleted. #&#39; #&#39; @return filtered report #&#39; @export filter_taxon &lt;- function(report, filter_taxon, rm_clade = TRUE, do_message=FALSE) { taxon_depth &lt;- NULL taxonReads &lt;- 0 pos.taxons &lt;- which(sub(&quot;._&quot;,&quot;&quot;,report$name) %in% filter_taxon) #pos.taxon &lt;- which(report$name := filter_taxon) if (length(pos.taxons) == 0) { return(report) } row_seq &lt;- seq_len(nrow(report)) rows_to_delete &lt;- rep(FALSE,nrow(report)) taxon_depths &lt;- report[pos.taxons,&quot;depth&quot;] if (isTRUE(rm_clade)) { taxonReads &lt;- report[pos.taxons,&quot;cladeReads&quot;] } else { taxonReads &lt;- report[pos.taxons,&quot;taxonReads&quot;] report[pos.taxons,&quot;taxonReads&quot;] &lt;- 0 } for (i in seq_along(pos.taxons)) { pos.taxon &lt;- pos.taxons[i] if (pos.taxon == 1) { rows_to_delete[1] &lt;- TRUE next } taxon_depth &lt;- taxon_depths[i] taxonReads &lt;- taxonReads[i] if (rm_clade) { tosum_below &lt;- row_seq &gt;= pos.taxon &amp; report$depth &lt;= taxon_depth taxons_below &lt;- cumsum(tosum_below) == 1 rows_to_delete[taxons_below] &lt;- TRUE } rows_to_update &lt;- c(pos.taxon) taxons_above &lt;- seq_len(nrow(report)) &lt; pos.taxon &amp; report$depth == taxon_depth any_stays &lt;- FALSE prev_taxon_depth &lt;- taxon_depth taxons_above &lt;- c() for (i in seq(from=(pos.taxon-1),to=1)) { curr_taxon_depth &lt;- report[i,&quot;depth&quot;] if (curr_taxon_depth &lt; prev_taxon_depth) { if (!any_stays) { if (report[i,&quot;cladeReads&quot;] == taxonReads) { rows_to_delete[i] &lt;- TRUE if (do_message) message(&quot;Deleting &quot;,report[i,&quot;name&quot;]) } else { any_stays &lt;- TRUE } } if (!rows_to_delete[i]) { rows_to_update &lt;- c(rows_to_update, i) if (do_message) message(&quot;Updating &quot;,report[i,&quot;name&quot;]) } prev_taxon_depth &lt;- curr_taxon_depth } else { any_stays &lt;- TRUE } } report[rows_to_update, &quot;cladeReads&quot;] &lt;- report[rows_to_update, &quot;cladeReads&quot;] - taxonReads } #if (rm_clade) report[!rows_to_delete,] #else # report } taxRanks = c(&quot;G&quot;) reports &lt;- list.files(&quot;kraken/reports&quot;, full.names =T) res &lt;- list() for (report in reports) { dat &lt;- read_report(report) stopifnot(&quot;taxRank&quot; %in% colnames(dat)) if (!any(taxRanks %in% dat$taxRank)) { warning(&quot;report does not contain any of the taxRanks - skipping it&quot;) return() } dat &lt;- subset(dat, taxRank %in% taxRanks) basename &lt;- sub(pattern = &quot;(.*)\\\\..*$&quot;, replacement = &quot;\\\\1&quot;, basename(report)) basename2 &lt;- sub(pattern = &quot;(.*)\\\\..*$&quot;, replacement = &quot;\\\\1&quot;, basename) res[[basename2]] &lt;- data.frame(sample = basename2, ra = dat$percentage, name=dat$name, reads=dat$taxonReads) } df &lt;- as.data.frame(do.call(rbind, res)) # set everything lower than 1% to other df$name &lt;- as.character(as.matrix(df$name)) df[which(df$ra &lt; 0.1),]$name &lt;- &quot;other&quot; 6.1 plot require(ggplot2) library(RColorBrewer) mycolors &lt;- colorRampPalette(brewer.pal(8, &quot;Dark2&quot;))(length(unique(df$name))) p &lt;- ggplot(df, aes(x = sample, y = ra, fill = name)) p &lt;- p + geom_bar(stat = &quot;identity&quot;) + theme_minimal() + scale_fill_manual(values = mycolors) p &lt;- p + theme(axis.text.x = element_text(angle = 90, hjust = 1)) plotly::ggplotly(p) "]
]
